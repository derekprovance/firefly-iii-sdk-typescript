/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v1.5.6
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00 
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updated_at'?: string;
    /**
     * If omitted, defaults to true.
     * @type {boolean}
     * @memberof Account
     */
    'active'?: boolean;
    /**
     * Order of the account. Is NULL if account is not asset or liability.
     * @type {number}
     * @memberof Account
     */
    'order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {ShortAccountTypeProperty}
     * @memberof Account
     */
    'type': ShortAccountTypeProperty;
    /**
     * 
     * @type {AccountRoleProperty}
     * @memberof Account
     */
    'account_role'?: AccountRoleProperty | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof Account
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof Account
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'currency_decimal_places'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'current_balance'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'current_balance_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'iban'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'bic'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'account_number'?: string | null;
    /**
     * Represents the opening balance, the initial amount this account holds.
     * @type {string}
     * @memberof Account
     */
    'opening_balance'?: string;
    /**
     * Represents the current debt for liabilities.
     * @type {string}
     * @memberof Account
     */
    'current_debt'?: string | null;
    /**
     * Represents the date of the opening balance.
     * @type {string}
     * @memberof Account
     */
    'opening_balance_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'virtual_balance'?: string;
    /**
     * If omitted, defaults to true.
     * @type {boolean}
     * @memberof Account
     */
    'include_net_worth'?: boolean;
    /**
     * 
     * @type {CreditCardType}
     * @memberof Account
     */
    'credit_card_type'?: CreditCardType | null;
    /**
     * Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
     * @type {string}
     * @memberof Account
     */
    'monthly_payment_date'?: string | null;
    /**
     * 
     * @type {LiabilityType}
     * @memberof Account
     */
    'liability_type'?: LiabilityType | null;
    /**
     * 
     * @type {LiabilityDirection}
     * @memberof Account
     */
    'liability_direction'?: LiabilityDirection | null;
    /**
     * Mandatory when type is liability. Interest percentage.
     * @type {string}
     * @memberof Account
     */
    'interest'?: string | null;
    /**
     * 
     * @type {LiabilityDirection}
     * @memberof Account
     */
    'interest_period'?: LiabilityDirection | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'notes'?: string | null;
    /**
     * Latitude of the accounts\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof Account
     */
    'latitude'?: number | null;
    /**
     * Latitude of the accounts\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof Account
     */
    'longitude'?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     * @type {number}
     * @memberof Account
     */
    'zoom_level'?: number | null;
}
/**
 * 
 * @export
 * @interface AccountArray
 */
export interface AccountArray {
    /**
     * 
     * @type {Array<AccountRead>}
     * @memberof AccountArray
     */
    'data': Array<AccountRead>;
    /**
     * 
     * @type {Meta}
     * @memberof AccountArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface AccountRead
 */
export interface AccountRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof AccountRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AccountRead
     */
    'id': string;
    /**
     * 
     * @type {Account}
     * @memberof AccountRead
     */
    'attributes': Account;
}
/**
 * Is only mandatory when the type is asset.
 * @export
 * @enum {string}
 */

export const AccountRoleProperty = {
    DefaultAsset: 'defaultAsset',
    SharedAsset: 'sharedAsset',
    SavingAsset: 'savingAsset',
    CcAsset: 'ccAsset',
    CashWalletAsset: 'cashWalletAsset',
    Null: 'null'
} as const;

export type AccountRoleProperty = typeof AccountRoleProperty[keyof typeof AccountRoleProperty];


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountSearchFieldFilter = {
    All: 'all',
    Iban: 'iban',
    Name: 'name',
    Number: 'number',
    Id: 'id'
} as const;

export type AccountSearchFieldFilter = typeof AccountSearchFieldFilter[keyof typeof AccountSearchFieldFilter];


/**
 * 
 * @export
 * @interface AccountSingle
 */
export interface AccountSingle {
    /**
     * 
     * @type {AccountRead}
     * @memberof AccountSingle
     */
    'data': AccountRead;
}
/**
 * 
 * @export
 * @interface AccountStore
 */
export interface AccountStore {
    /**
     * 
     * @type {string}
     * @memberof AccountStore
     */
    'name': string;
    /**
     * 
     * @type {ShortAccountTypeProperty}
     * @memberof AccountStore
     */
    'type': ShortAccountTypeProperty;
    /**
     * 
     * @type {string}
     * @memberof AccountStore
     */
    'iban'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountStore
     */
    'bic'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountStore
     */
    'account_number'?: string | null;
    /**
     * Represents the opening balance, the initial amount this account holds.
     * @type {string}
     * @memberof AccountStore
     */
    'opening_balance'?: string;
    /**
     * Represents the date of the opening balance.
     * @type {string}
     * @memberof AccountStore
     */
    'opening_balance_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountStore
     */
    'virtual_balance'?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof AccountStore
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof AccountStore
     */
    'currency_code'?: string;
    /**
     * If omitted, defaults to true.
     * @type {boolean}
     * @memberof AccountStore
     */
    'active'?: boolean;
    /**
     * Order of the account
     * @type {number}
     * @memberof AccountStore
     */
    'order'?: number;
    /**
     * If omitted, defaults to true.
     * @type {boolean}
     * @memberof AccountStore
     */
    'include_net_worth'?: boolean;
    /**
     * 
     * @type {AccountRoleProperty}
     * @memberof AccountStore
     */
    'account_role'?: AccountRoleProperty | null;
    /**
     * 
     * @type {CreditCardType}
     * @memberof AccountStore
     */
    'credit_card_type'?: CreditCardType | null;
    /**
     * Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
     * @type {string}
     * @memberof AccountStore
     */
    'monthly_payment_date'?: string | null;
    /**
     * 
     * @type {LiabilityType}
     * @memberof AccountStore
     */
    'liability_type'?: LiabilityType | null;
    /**
     * 
     * @type {LiabilityDirection}
     * @memberof AccountStore
     */
    'liability_direction'?: LiabilityDirection | null;
    /**
     * Mandatory when type is liability. Interest percentage.
     * @type {string}
     * @memberof AccountStore
     */
    'interest'?: string | null;
    /**
     * 
     * @type {InterestPeriod}
     * @memberof AccountStore
     */
    'interest_period'?: InterestPeriod | null;
    /**
     * 
     * @type {string}
     * @memberof AccountStore
     */
    'notes'?: string | null;
    /**
     * Latitude of the accounts\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof AccountStore
     */
    'latitude'?: number | null;
    /**
     * Latitude of the accounts\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof AccountStore
     */
    'longitude'?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     * @type {number}
     * @memberof AccountStore
     */
    'zoom_level'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountTypeFilter = {
    All: 'all',
    Asset: 'asset',
    Cash: 'cash',
    Expense: 'expense',
    Revenue: 'revenue',
    Special: 'special',
    Hidden: 'hidden',
    Liability: 'liability',
    Liabilities: 'liabilities',
    DefaultAccount: 'Default account',
    CashAccount: 'Cash account',
    AssetAccount: 'Asset account',
    ExpenseAccount: 'Expense account',
    RevenueAccount: 'Revenue account',
    InitialBalanceAccount: 'Initial balance account',
    BeneficiaryAccount: 'Beneficiary account',
    ImportAccount: 'Import account',
    ReconciliationAccount: 'Reconciliation account',
    Loan: 'Loan',
    Debt: 'Debt',
    Mortgage: 'Mortgage'
} as const;

export type AccountTypeFilter = typeof AccountTypeFilter[keyof typeof AccountTypeFilter];


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountTypeProperty = {
    DefaultAccount: 'Default account',
    CashAccount: 'Cash account',
    AssetAccount: 'Asset account',
    ExpenseAccount: 'Expense account',
    RevenueAccount: 'Revenue account',
    InitialBalanceAccount: 'Initial balance account',
    BeneficiaryAccount: 'Beneficiary account',
    ImportAccount: 'Import account',
    ReconciliationAccount: 'Reconciliation account',
    Loan: 'Loan',
    Debt: 'Debt',
    Mortgage: 'Mortgage'
} as const;

export type AccountTypeProperty = typeof AccountTypeProperty[keyof typeof AccountTypeProperty];


/**
 * 
 * @export
 * @interface AccountUpdate
 */
export interface AccountUpdate {
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'iban'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'bic'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'opening_balance'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'opening_balance_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'virtual_balance'?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof AccountUpdate
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof AccountUpdate
     */
    'currency_code'?: string;
    /**
     * If omitted, defaults to true.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'active'?: boolean;
    /**
     * Order of the account
     * @type {number}
     * @memberof AccountUpdate
     */
    'order'?: number;
    /**
     * If omitted, defaults to true.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'include_net_worth'?: boolean;
    /**
     * 
     * @type {AccountRoleProperty}
     * @memberof AccountUpdate
     */
    'account_role'?: AccountRoleProperty | null;
    /**
     * 
     * @type {CreditCardType}
     * @memberof AccountUpdate
     */
    'credit_card_type'?: CreditCardType | null;
    /**
     * Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank.
     * @type {string}
     * @memberof AccountUpdate
     */
    'monthly_payment_date'?: string | null;
    /**
     * 
     * @type {LiabilityType}
     * @memberof AccountUpdate
     */
    'liability_type'?: LiabilityType | null;
    /**
     * Mandatory when type is liability. Interest percentage.
     * @type {string}
     * @memberof AccountUpdate
     */
    'interest'?: string | null;
    /**
     * 
     * @type {InterestPeriod}
     * @memberof AccountUpdate
     */
    'interest_period'?: InterestPeriod | null;
    /**
     * 
     * @type {string}
     * @memberof AccountUpdate
     */
    'notes'?: string | null;
    /**
     * Latitude of the account\'s location, if applicable. Can be used to draw a map. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
     * @type {number}
     * @memberof AccountUpdate
     */
    'latitude'?: number | null;
    /**
     * Latitude of the account\'s location, if applicable. Can be used to draw a map. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
     * @type {number}
     * @memberof AccountUpdate
     */
    'longitude'?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels. If omitted, the existing location will be kept. If submitted as NULL, the current location will be removed.
     * @type {number}
     * @memberof AccountUpdate
     */
    'zoom_level'?: number | null;
}
/**
 * The object class to which the attachment must be linked.
 * @export
 * @enum {string}
 */

export const AttachableType = {
    Account: 'Account',
    Budget: 'Budget',
    Bill: 'Bill',
    TransactionJournal: 'TransactionJournal',
    PiggyBank: 'PiggyBank',
    Tag: 'Tag'
} as const;

export type AttachableType = typeof AttachableType[keyof typeof AttachableType];


/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'updated_at'?: string;
    /**
     * 
     * @type {AttachableType}
     * @memberof Attachment
     */
    'attachable_type': AttachableType;
    /**
     * ID of the model this attachment is linked to.
     * @type {string}
     * @memberof Attachment
     */
    'attachable_id': string;
    /**
     * MD5 hash of the file for basic duplicate detection.
     * @type {string}
     * @memberof Attachment
     */
    'md5'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'download_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'upload_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'mime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface AttachmentArray
 */
export interface AttachmentArray {
    /**
     * 
     * @type {Array<AttachmentRead>}
     * @memberof AttachmentArray
     */
    'data': Array<AttachmentRead>;
    /**
     * 
     * @type {Meta}
     * @memberof AttachmentArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface AttachmentRead
 */
export interface AttachmentRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof AttachmentRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentRead
     */
    'id': string;
    /**
     * 
     * @type {Attachment}
     * @memberof AttachmentRead
     */
    'attributes': Attachment;
    /**
     * 
     * @type {ObjectLink}
     * @memberof AttachmentRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface AttachmentSingle
 */
export interface AttachmentSingle {
    /**
     * 
     * @type {AttachmentRead}
     * @memberof AttachmentSingle
     */
    'data': AttachmentRead;
}
/**
 * 
 * @export
 * @interface AttachmentStore
 */
export interface AttachmentStore {
    /**
     * 
     * @type {string}
     * @memberof AttachmentStore
     */
    'filename': string;
    /**
     * 
     * @type {AttachableType}
     * @memberof AttachmentStore
     */
    'attachable_type': AttachableType;
    /**
     * ID of the model this attachment is linked to.
     * @type {string}
     * @memberof AttachmentStore
     */
    'attachable_id': string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentStore
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentStore
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface AttachmentUpdate
 */
export interface AttachmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof AttachmentUpdate
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentUpdate
     */
    'notes'?: string | null;
}
/**
 * Period for the auto budget
 * @export
 * @enum {string}
 */

export const AutoBudgetPeriod = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    HalfYear: 'half-year',
    Yearly: 'yearly',
    Null: 'null'
} as const;

export type AutoBudgetPeriod = typeof AutoBudgetPeriod[keyof typeof AutoBudgetPeriod];


/**
 * The type of auto-budget that Firefly III must create.
 * @export
 * @enum {string}
 */

export const AutoBudgetType = {
    Reset: 'reset',
    Rollover: 'rollover',
    None: 'none',
    Null: 'null'
} as const;

export type AutoBudgetType = typeof AutoBudgetType[keyof typeof AutoBudgetType];


/**
 * 
 * @export
 * @interface AutocompleteAccount
 */
export interface AutocompleteAccount {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'id': string;
    /**
     * Name of the account found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'name': string;
    /**
     * Asset accounts and liabilities have a second field with the given date\'s account balance.
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'name_with_balance': string;
    /**
     * Account type of the account found by the auto-complete search.
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'type': string;
    /**
     * ID for the currency used by this account.
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'currency_id': string;
    /**
     * Currency name for the currency used by this account.
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'currency_name': string;
    /**
     * Currency code for the currency used by this account.
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'currency_code': string;
    /**
     * Currency symbol for the currency used by this account.
     * @type {string}
     * @memberof AutocompleteAccount
     */
    'currency_symbol': string;
    /**
     * Number of decimal places for the currency used by this account.
     * @type {number}
     * @memberof AutocompleteAccount
     */
    'currency_decimal_places': number;
}
/**
 * 
 * @export
 * @interface AutocompleteBill
 */
export interface AutocompleteBill {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteBill
     */
    'id': string;
    /**
     * Name of the bill found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteBill
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AutocompleteBudget
 */
export interface AutocompleteBudget {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteBudget
     */
    'id': string;
    /**
     * Name of the budget found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteBudget
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AutocompleteCategory
 */
export interface AutocompleteCategory {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteCategory
     */
    'id': string;
    /**
     * Name of the category found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteCategory
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AutocompleteCurrency
 */
export interface AutocompleteCurrency {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteCurrency
     */
    'id': string;
    /**
     * Currency name.
     * @type {string}
     * @memberof AutocompleteCurrency
     */
    'name': string;
    /**
     * Currency code.
     * @type {string}
     * @memberof AutocompleteCurrency
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteCurrency
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof AutocompleteCurrency
     */
    'decimal_places': number;
}
/**
 * 
 * @export
 * @interface AutocompleteCurrencyCode
 */
export interface AutocompleteCurrencyCode {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteCurrencyCode
     */
    'id': string;
    /**
     * Currency name with the code between brackets.
     * @type {string}
     * @memberof AutocompleteCurrencyCode
     */
    'name': string;
    /**
     * Currency code.
     * @type {string}
     * @memberof AutocompleteCurrencyCode
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteCurrencyCode
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof AutocompleteCurrencyCode
     */
    'decimal_places': number;
}
/**
 * 
 * @export
 * @interface AutocompleteObjectGroup
 */
export interface AutocompleteObjectGroup {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteObjectGroup
     */
    'id': string;
    /**
     * Title of the object group found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteObjectGroup
     */
    'title': string;
    /**
     * Title of the object group found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteObjectGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AutocompletePiggy
 */
export interface AutocompletePiggy {
    /**
     * 
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'id': string;
    /**
     * Name of the piggy bank found by an auto-complete search.
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'name': string;
    /**
     * Currency ID for this piggy bank.
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'currency_id'?: string;
    /**
     * Currency code for this piggy bank.
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'currency_symbol'?: string;
    /**
     * Currency name for the currency used by this account.
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'currency_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AutocompletePiggy
     */
    'currency_decimal_places'?: number;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'object_group_id'?: string | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof AutocompletePiggy
     */
    'object_group_title'?: string | null;
}
/**
 * 
 * @export
 * @interface AutocompletePiggyBalance
 */
export interface AutocompletePiggyBalance {
    /**
     * 
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'id': string;
    /**
     * Name of the piggy bank found by an auto-complete search.
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'name': string;
    /**
     * Name of the piggy bank found by an auto-complete search with the current balance formatted nicely.
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'name_with_balance'?: string;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'object_group_id'?: string | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'object_group_title'?: string | null;
    /**
     * Currency ID for this piggy bank.
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'currency_id'?: string;
    /**
     * Currency code for this piggy bank.
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutocompletePiggyBalance
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof AutocompletePiggyBalance
     */
    'currency_decimal_places'?: number;
}
/**
 * 
 * @export
 * @interface AutocompleteRecurrence
 */
export interface AutocompleteRecurrence {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteRecurrence
     */
    'id': string;
    /**
     * Name of the recurrence found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteRecurrence
     */
    'name': string;
    /**
     * Description of the recurrence found by auto-complete.
     * @type {string}
     * @memberof AutocompleteRecurrence
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AutocompleteRule
 */
export interface AutocompleteRule {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteRule
     */
    'id': string;
    /**
     * Name of the rule found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteRule
     */
    'name': string;
    /**
     * Description of the rule found by auto-complete.
     * @type {string}
     * @memberof AutocompleteRule
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AutocompleteRuleGroup
 */
export interface AutocompleteRuleGroup {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteRuleGroup
     */
    'id': string;
    /**
     * Name of the rule group found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteRuleGroup
     */
    'name': string;
    /**
     * Description of the rule group found by auto-complete.
     * @type {string}
     * @memberof AutocompleteRuleGroup
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AutocompleteTag
 */
export interface AutocompleteTag {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteTag
     */
    'id': string;
    /**
     * Name of the tag found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteTag
     */
    'name': string;
    /**
     * Name of the tag found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteTag
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface AutocompleteTransaction
 */
export interface AutocompleteTransaction {
    /**
     * The ID of a transaction journal (basically a single split).
     * @type {string}
     * @memberof AutocompleteTransaction
     */
    'id': string;
    /**
     * The ID of the underlying transaction group.
     * @type {string}
     * @memberof AutocompleteTransaction
     */
    'transaction_group_id'?: string;
    /**
     * Transaction description
     * @type {string}
     * @memberof AutocompleteTransaction
     */
    'name': string;
    /**
     * Transaction description
     * @type {string}
     * @memberof AutocompleteTransaction
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface AutocompleteTransactionID
 */
export interface AutocompleteTransactionID {
    /**
     * The ID of a transaction journal (basically a single split).
     * @type {string}
     * @memberof AutocompleteTransactionID
     */
    'id': string;
    /**
     * The ID of the underlying transaction group.
     * @type {string}
     * @memberof AutocompleteTransactionID
     */
    'transaction_group_id'?: string;
    /**
     * Transaction description with ID in the name.
     * @type {string}
     * @memberof AutocompleteTransactionID
     */
    'name': string;
    /**
     * Transaction description with ID in the name.
     * @type {string}
     * @memberof AutocompleteTransactionID
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface AutocompleteTransactionType
 */
export interface AutocompleteTransactionType {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteTransactionType
     */
    'id': string;
    /**
     * Type of the object found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteTransactionType
     */
    'name': string;
    /**
     * Name of the object found by an auto-complete search.
     * @type {string}
     * @memberof AutocompleteTransactionType
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface AvailableBudget
 */
export interface AvailableBudget {
    /**
     * 
     * @type {string}
     * @memberof AvailableBudget
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvailableBudget
     */
    'updated_at'?: string;
    /**
     * Use either currency_id or currency_code.
     * @type {string}
     * @memberof AvailableBudget
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code.
     * @type {string}
     * @memberof AvailableBudget
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvailableBudget
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof AvailableBudget
     */
    'currency_decimal_places'?: number;
    /**
     * 
     * @type {string}
     * @memberof AvailableBudget
     */
    'amount': string;
    /**
     * Start date of the available budget.
     * @type {string}
     * @memberof AvailableBudget
     */
    'start': string;
    /**
     * End date of the available budget.
     * @type {string}
     * @memberof AvailableBudget
     */
    'end': string;
    /**
     * 
     * @type {Array<BudgetSpent>}
     * @memberof AvailableBudget
     */
    'spent_in_budgets'?: Array<BudgetSpent>;
    /**
     * 
     * @type {Array<BudgetSpent>}
     * @memberof AvailableBudget
     */
    'spent_outside_budget'?: Array<BudgetSpent>;
}
/**
 * 
 * @export
 * @interface AvailableBudgetArray
 */
export interface AvailableBudgetArray {
    /**
     * 
     * @type {Array<AvailableBudgetRead>}
     * @memberof AvailableBudgetArray
     */
    'data': Array<AvailableBudgetRead>;
    /**
     * 
     * @type {Meta}
     * @memberof AvailableBudgetArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface AvailableBudgetRead
 */
export interface AvailableBudgetRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof AvailableBudgetRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof AvailableBudgetRead
     */
    'id': string;
    /**
     * 
     * @type {AvailableBudget}
     * @memberof AvailableBudgetRead
     */
    'attributes': AvailableBudget;
}
/**
 * 
 * @export
 * @interface AvailableBudgetSingle
 */
export interface AvailableBudgetSingle {
    /**
     * 
     * @type {AvailableBudgetRead}
     * @memberof AvailableBudgetSingle
     */
    'data': AvailableBudgetRead;
}
/**
 * 
 * @export
 * @interface AvailableBudgetStore
 */
export interface AvailableBudgetStore {
    /**
     * Use either currency_id or currency_code.
     * @type {string}
     * @memberof AvailableBudgetStore
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code.
     * @type {string}
     * @memberof AvailableBudgetStore
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvailableBudgetStore
     */
    'amount': string;
    /**
     * Start date of the available budget.
     * @type {string}
     * @memberof AvailableBudgetStore
     */
    'start': string;
    /**
     * End date of the available budget.
     * @type {string}
     * @memberof AvailableBudgetStore
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface AvailableBudgetUpdate
 */
export interface AvailableBudgetUpdate {
    /**
     * Use either currency_id or currency_code.
     * @type {string}
     * @memberof AvailableBudgetUpdate
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code.
     * @type {string}
     * @memberof AvailableBudgetUpdate
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvailableBudgetUpdate
     */
    'amount'?: string;
    /**
     * Start date of the available budget.
     * @type {string}
     * @memberof AvailableBudgetUpdate
     */
    'start'?: string;
    /**
     * End date of the available budget.
     * @type {string}
     * @memberof AvailableBudgetUpdate
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface BasicSummaryEntry
 */
export interface BasicSummaryEntry {
    /**
     * This is a reference to the type of info shared, not influenced by translations or user preferences. The EUR value is a reference to the currency code. Possibilities are: balance-in-ABC, spent-in-ABC, earned-in-ABC, bills-paid-in-ABC, bills-unpaid-in-ABC, left-to-spend-in-ABC and net-worth-in-ABC.
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'key'?: string;
    /**
     * A translated title for the information shared.
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'title'?: string;
    /**
     * The amount as a float.
     * @type {number}
     * @memberof BasicSummaryEntry
     */
    'monetary_value'?: number;
    /**
     * The currency ID of the associated currency.
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'currency_symbol'?: string;
    /**
     * Number of decimals for the associated currency.
     * @type {number}
     * @memberof BasicSummaryEntry
     */
    'currency_decimal_places'?: number;
    /**
     * The amount formatted according to the users locale
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'value_parsed'?: string;
    /**
     * Reference to a font-awesome icon without the fa- part.
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'local_icon'?: string;
    /**
     * A short explanation of the amounts origin. Already formatted according to the locale of the user or translated, if relevant.
     * @type {string}
     * @memberof BasicSummaryEntry
     */
    'sub_title'?: string;
}
/**
 * 
 * @export
 * @interface Bill
 */
export interface Bill {
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'updated_at'?: string;
    /**
     * Use either currency_id or currency_code
     * @type {string}
     * @memberof Bill
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code
     * @type {string}
     * @memberof Bill
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof Bill
     */
    'currency_decimal_places'?: number;
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'amount_min': string;
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'amount_max': string;
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'date': string;
    /**
     * The date after which this bill is no longer valid or applicable
     * @type {string}
     * @memberof Bill
     */
    'end_date'?: string;
    /**
     * The date before which the bill must be renewed (or cancelled)
     * @type {string}
     * @memberof Bill
     */
    'extension_date'?: string;
    /**
     * 
     * @type {BillRepeatFrequency}
     * @memberof Bill
     */
    'repeat_freq': BillRepeatFrequency;
    /**
     * How often the bill must be skipped. 1 means a bi-monthly bill.
     * @type {number}
     * @memberof Bill
     */
    'skip'?: number;
    /**
     * If the bill is active.
     * @type {boolean}
     * @memberof Bill
     */
    'active'?: boolean;
    /**
     * Order of the bill.
     * @type {number}
     * @memberof Bill
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof Bill
     */
    'notes'?: string | null;
    /**
     * When the bill is expected to be due.
     * @type {string}
     * @memberof Bill
     */
    'next_expected_match'?: string | null;
    /**
     * Formatted (locally) when the bill is due.
     * @type {string}
     * @memberof Bill
     */
    'next_expected_match_diff'?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof Bill
     */
    'object_group_id'?: string | null;
    /**
     * The order of the group. At least 1, for the highest sorting.
     * @type {number}
     * @memberof Bill
     */
    'object_group_order'?: number | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof Bill
     */
    'object_group_title'?: string | null;
    /**
     * Array of future dates when the bill is expected to be paid. Autogenerated.
     * @type {Array<string>}
     * @memberof Bill
     */
    'pay_dates'?: Array<string>;
    /**
     * Array of past transactions when the bill was paid.
     * @type {Array<BillPaidDatesInner>}
     * @memberof Bill
     */
    'paid_dates'?: Array<BillPaidDatesInner>;
}
/**
 * 
 * @export
 * @interface BillArray
 */
export interface BillArray {
    /**
     * 
     * @type {Array<BillRead>}
     * @memberof BillArray
     */
    'data': Array<BillRead>;
    /**
     * 
     * @type {Meta}
     * @memberof BillArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface BillPaidDatesInner
 */
export interface BillPaidDatesInner {
    /**
     * Transaction group ID of the paid bill.
     * @type {string}
     * @memberof BillPaidDatesInner
     */
    'transaction_group_id'?: string;
    /**
     * Transaction journal ID of the paid bill.
     * @type {string}
     * @memberof BillPaidDatesInner
     */
    'transaction_journal_id'?: string;
    /**
     * Date the bill was paid.
     * @type {string}
     * @memberof BillPaidDatesInner
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface BillRead
 */
export interface BillRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof BillRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof BillRead
     */
    'id': string;
    /**
     * 
     * @type {Bill}
     * @memberof BillRead
     */
    'attributes': Bill;
}
/**
 * How often the bill must be paid.
 * @export
 * @enum {string}
 */

export const BillRepeatFrequency = {
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    HalfYear: 'half-year',
    Yearly: 'yearly'
} as const;

export type BillRepeatFrequency = typeof BillRepeatFrequency[keyof typeof BillRepeatFrequency];


/**
 * 
 * @export
 * @interface BillSingle
 */
export interface BillSingle {
    /**
     * 
     * @type {BillRead}
     * @memberof BillSingle
     */
    'data': BillRead;
}
/**
 * 
 * @export
 * @interface BillStore
 */
export interface BillStore {
    /**
     * Use either currency_id or currency_code
     * @type {string}
     * @memberof BillStore
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code
     * @type {string}
     * @memberof BillStore
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillStore
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BillStore
     */
    'amount_min': string;
    /**
     * 
     * @type {string}
     * @memberof BillStore
     */
    'amount_max': string;
    /**
     * 
     * @type {string}
     * @memberof BillStore
     */
    'date': string;
    /**
     * The date after which this bill is no longer valid or applicable
     * @type {string}
     * @memberof BillStore
     */
    'end_date'?: string;
    /**
     * The date before which the bill must be renewed (or cancelled)
     * @type {string}
     * @memberof BillStore
     */
    'extension_date'?: string;
    /**
     * 
     * @type {BillRepeatFrequency}
     * @memberof BillStore
     */
    'repeat_freq': BillRepeatFrequency;
    /**
     * How often the bill must be skipped. 1 means a bi-monthly bill.
     * @type {number}
     * @memberof BillStore
     */
    'skip'?: number;
    /**
     * If the bill is active.
     * @type {boolean}
     * @memberof BillStore
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BillStore
     */
    'notes'?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof BillStore
     */
    'object_group_id'?: string | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof BillStore
     */
    'object_group_title'?: string | null;
}
/**
 * 
 * @export
 * @interface BillUpdate
 */
export interface BillUpdate {
    /**
     * Use either currency_id or currency_code
     * @type {string}
     * @memberof BillUpdate
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code
     * @type {string}
     * @memberof BillUpdate
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillUpdate
     */
    'amount_min'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillUpdate
     */
    'amount_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof BillUpdate
     */
    'date'?: string;
    /**
     * The date after which this bill is no longer valid or applicable
     * @type {string}
     * @memberof BillUpdate
     */
    'end_date'?: string;
    /**
     * The date before which the bill must be renewed (or cancelled)
     * @type {string}
     * @memberof BillUpdate
     */
    'extension_date'?: string;
    /**
     * 
     * @type {BillRepeatFrequency}
     * @memberof BillUpdate
     */
    'repeat_freq'?: BillRepeatFrequency;
    /**
     * How often the bill must be skipped. 1 means a bi-monthly bill.
     * @type {number}
     * @memberof BillUpdate
     */
    'skip'?: number;
    /**
     * If the bill is active.
     * @type {boolean}
     * @memberof BillUpdate
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BillUpdate
     */
    'notes'?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof BillUpdate
     */
    'object_group_id'?: string | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof BillUpdate
     */
    'object_group_title'?: string | null;
}
/**
 * 
 * @export
 * @interface Budget
 */
export interface Budget {
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Budget
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'notes'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Budget
     */
    'order'?: number;
    /**
     * 
     * @type {AutoBudgetType}
     * @memberof Budget
     */
    'auto_budget_type'?: AutoBudgetType | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof Budget
     */
    'auto_budget_currency_id'?: string | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof Budget
     */
    'auto_budget_currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'auto_budget_amount'?: string | null;
    /**
     * 
     * @type {AutoBudgetPeriod}
     * @memberof Budget
     */
    'auto_budget_period'?: AutoBudgetPeriod | null;
    /**
     * Information on how much was spent in this budget. Is only filled in when the start and end date are submitted.
     * @type {Array<BudgetSpent>}
     * @memberof Budget
     */
    'spent'?: Array<BudgetSpent>;
}
/**
 * 
 * @export
 * @interface BudgetArray
 */
export interface BudgetArray {
    /**
     * 
     * @type {Array<BudgetRead>}
     * @memberof BudgetArray
     */
    'data': Array<BudgetRead>;
    /**
     * 
     * @type {Meta}
     * @memberof BudgetArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface BudgetLimit
 */
export interface BudgetLimit {
    /**
     * 
     * @type {string}
     * @memberof BudgetLimit
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetLimit
     */
    'updated_at'?: string;
    /**
     * Start date of the budget limit.
     * @type {string}
     * @memberof BudgetLimit
     */
    'start': string;
    /**
     * End date of the budget limit.
     * @type {string}
     * @memberof BudgetLimit
     */
    'end': string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetLimit
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetLimit
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetLimit
     */
    'currency_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetLimit
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof BudgetLimit
     */
    'currency_decimal_places'?: number;
    /**
     * The budget ID of the associated budget.
     * @type {string}
     * @memberof BudgetLimit
     */
    'budget_id': string;
    /**
     * Period of the budget limit. Only used when auto-generated by auto-budget.
     * @type {string}
     * @memberof BudgetLimit
     */
    'period'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BudgetLimit
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof BudgetLimit
     */
    'spent'?: string | null;
}
/**
 * 
 * @export
 * @interface BudgetLimitArray
 */
export interface BudgetLimitArray {
    /**
     * 
     * @type {Array<BudgetLimitRead>}
     * @memberof BudgetLimitArray
     */
    'data': Array<BudgetLimitRead>;
    /**
     * 
     * @type {Meta}
     * @memberof BudgetLimitArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface BudgetLimitRead
 */
export interface BudgetLimitRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof BudgetLimitRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof BudgetLimitRead
     */
    'id': string;
    /**
     * 
     * @type {BudgetLimit}
     * @memberof BudgetLimitRead
     */
    'attributes': BudgetLimit;
}
/**
 * 
 * @export
 * @interface BudgetLimitSingle
 */
export interface BudgetLimitSingle {
    /**
     * 
     * @type {BudgetLimitRead}
     * @memberof BudgetLimitSingle
     */
    'data': BudgetLimitRead;
}
/**
 * 
 * @export
 * @interface BudgetLimitStore
 */
export interface BudgetLimitStore {
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetLimitStore
     */
    'currency_id'?: string;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetLimitStore
     */
    'currency_code'?: string;
    /**
     * The budget ID of the associated budget.
     * @type {string}
     * @memberof BudgetLimitStore
     */
    'budget_id': string;
    /**
     * Start date of the budget limit.
     * @type {string}
     * @memberof BudgetLimitStore
     */
    'start': string;
    /**
     * Period of the budget limit. Only used when auto-generated by auto-budget.
     * @type {string}
     * @memberof BudgetLimitStore
     */
    'period'?: string | null;
    /**
     * End date of the budget limit.
     * @type {string}
     * @memberof BudgetLimitStore
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof BudgetLimitStore
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface BudgetRead
 */
export interface BudgetRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof BudgetRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof BudgetRead
     */
    'id': string;
    /**
     * 
     * @type {Budget}
     * @memberof BudgetRead
     */
    'attributes': Budget;
}
/**
 * 
 * @export
 * @interface BudgetSingle
 */
export interface BudgetSingle {
    /**
     * 
     * @type {BudgetRead}
     * @memberof BudgetSingle
     */
    'data': BudgetRead;
}
/**
 * 
 * @export
 * @interface BudgetSpent
 */
export interface BudgetSpent {
    /**
     * The amount spent.
     * @type {string}
     * @memberof BudgetSpent
     */
    'sum'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetSpent
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetSpent
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetSpent
     */
    'currency_symbol'?: string;
    /**
     * Number of decimals supported by the currency
     * @type {number}
     * @memberof BudgetSpent
     */
    'currency_decimal_places'?: number;
}
/**
 * 
 * @export
 * @interface BudgetStore
 */
export interface BudgetStore {
    /**
     * 
     * @type {string}
     * @memberof BudgetStore
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BudgetStore
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BudgetStore
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof BudgetStore
     */
    'notes'?: string | null;
    /**
     * 
     * @type {AutoBudgetType}
     * @memberof BudgetStore
     */
    'auto_budget_type'?: AutoBudgetType | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetStore
     */
    'auto_budget_currency_id'?: string | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetStore
     */
    'auto_budget_currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BudgetStore
     */
    'auto_budget_amount'?: string | null;
    /**
     * 
     * @type {AutoBudgetPeriod}
     * @memberof BudgetStore
     */
    'auto_budget_period'?: AutoBudgetPeriod | null;
}
/**
 * 
 * @export
 * @interface BudgetUpdate
 */
export interface BudgetUpdate {
    /**
     * 
     * @type {string}
     * @memberof BudgetUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BudgetUpdate
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BudgetUpdate
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof BudgetUpdate
     */
    'notes'?: string | null;
    /**
     * 
     * @type {AutoBudgetType}
     * @memberof BudgetUpdate
     */
    'auto_budget_type'?: AutoBudgetType | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetUpdate
     */
    'auto_budget_currency_id'?: string | null;
    /**
     * Use either currency_id or currency_code. Defaults to the user\'s default currency.
     * @type {string}
     * @memberof BudgetUpdate
     */
    'auto_budget_currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BudgetUpdate
     */
    'auto_budget_amount'?: string | null;
    /**
     * 
     * @type {AutoBudgetPeriod}
     * @memberof BudgetUpdate
     */
    'auto_budget_period'?: AutoBudgetPeriod | null;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'notes'?: string | null;
    /**
     * 
     * @type {Array<CategorySpent>}
     * @memberof Category
     */
    'spent'?: Array<CategorySpent>;
    /**
     * 
     * @type {Array<CategoryEarned>}
     * @memberof Category
     */
    'earned'?: Array<CategoryEarned>;
}
/**
 * 
 * @export
 * @interface CategoryArray
 */
export interface CategoryArray {
    /**
     * 
     * @type {Array<CategoryRead>}
     * @memberof CategoryArray
     */
    'data': Array<CategoryRead>;
    /**
     * 
     * @type {Meta}
     * @memberof CategoryArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface CategoryEarned
 */
export interface CategoryEarned {
    /**
     * 
     * @type {string}
     * @memberof CategoryEarned
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryEarned
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryEarned
     */
    'currency_symbol'?: string;
    /**
     * Number of decimals supported by the currency
     * @type {number}
     * @memberof CategoryEarned
     */
    'currency_decimal_places'?: number;
    /**
     * The amount earned.
     * @type {string}
     * @memberof CategoryEarned
     */
    'sum'?: string;
}
/**
 * 
 * @export
 * @interface CategoryRead
 */
export interface CategoryRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof CategoryRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryRead
     */
    'id': string;
    /**
     * 
     * @type {Category}
     * @memberof CategoryRead
     */
    'attributes': Category;
}
/**
 * 
 * @export
 * @interface CategorySingle
 */
export interface CategorySingle {
    /**
     * 
     * @type {CategoryRead}
     * @memberof CategorySingle
     */
    'data': CategoryRead;
}
/**
 * 
 * @export
 * @interface CategorySpent
 */
export interface CategorySpent {
    /**
     * 
     * @type {string}
     * @memberof CategorySpent
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategorySpent
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategorySpent
     */
    'currency_symbol'?: string;
    /**
     * Number of decimals supported by the currency
     * @type {number}
     * @memberof CategorySpent
     */
    'currency_decimal_places'?: number;
    /**
     * The amount spent.
     * @type {string}
     * @memberof CategorySpent
     */
    'sum'?: string;
}
/**
 * 
 * @export
 * @interface CategoryStore
 */
export interface CategoryStore {
    /**
     * 
     * @type {string}
     * @memberof CategoryStore
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryStore
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface CategoryUpdate
 */
export interface CategoryUpdate {
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdate
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface ChartDataPoint
 */
export interface ChartDataPoint {
    /**
     * The key is the label of the value, so for example: \'2018-01-01\' => 13 or \'Groceries\' => -123.
     * @type {string}
     * @memberof ChartDataPoint
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface ChartDataSet
 */
export interface ChartDataSet {
    /**
     * This is the title of the current set. It can refer to an account, a budget or another object (by name).
     * @type {string}
     * @memberof ChartDataSet
     */
    'label'?: string;
    /**
     * The currency ID of the currency associated to the data in the entries.
     * @type {string}
     * @memberof ChartDataSet
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataSet
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataSet
     */
    'currency_symbol'?: string;
    /**
     * Number of decimals for the currency associated to the data in the entries.
     * @type {number}
     * @memberof ChartDataSet
     */
    'currency_decimal_places'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChartDataSet
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChartDataSet
     */
    'end_date'?: string;
    /**
     * Indicated the type of chart that is expected to be rendered. You can safely ignore this if you want.
     * @type {string}
     * @memberof ChartDataSet
     */
    'type'?: string;
    /**
     * Used to indicate the Y axis for this data set. Is usually between 0 and 1 (left and right side of the chart).
     * @type {number}
     * @memberof ChartDataSet
     */
    'yAxisID'?: number;
    /**
     * The actual entries for this data set. They \'key\' value is the label for the data point. The value is the actual (numerical) value.
     * @type {Array<ChartDataPoint>}
     * @memberof ChartDataSet
     */
    'entries'?: Array<ChartDataPoint>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConfigValueFilter = {
    ConfigurationIsDemoSite: 'configuration.is_demo_site',
    ConfigurationPermissionUpdateCheck: 'configuration.permission_update_check',
    ConfigurationLastUpdateCheck: 'configuration.last_update_check',
    ConfigurationSingleUserMode: 'configuration.single_user_mode',
    FireflyVersion: 'firefly.version',
    FireflyApiVersion: 'firefly.api_version',
    FireflyDefaultLocation: 'firefly.default_location',
    FireflyAccountToTransaction: 'firefly.account_to_transaction',
    FireflyAllowedOpposingTypes: 'firefly.allowed_opposing_types',
    FireflyAccountRoles: 'firefly.accountRoles',
    FireflyValidLiabilities: 'firefly.valid_liabilities',
    FireflyInterestPeriods: 'firefly.interest_periods',
    FireflyEnableExternalMap: 'firefly.enable_external_map',
    FireflyExpectedSourceTypes: 'firefly.expected_source_types',
    AppTimezone: 'app.timezone',
    FireflyBillPeriods: 'firefly.bill_periods',
    FireflyCreditCardTypes: 'firefly.credit_card_types',
    FireflyLanguages: 'firefly.languages',
    FireflyValidViewRanges: 'firefly.valid_view_ranges'
} as const;

export type ConfigValueFilter = typeof ConfigValueFilter[keyof typeof ConfigValueFilter];


/**
 * 
 * @export
 * @enum {string}
 */

export const ConfigValueUpdateFilter = {
    IsDemoSite: 'configuration.is_demo_site',
    PermissionUpdateCheck: 'configuration.permission_update_check',
    LastUpdateCheck: 'configuration.last_update_check',
    SingleUserMode: 'configuration.single_user_mode'
} as const;

export type ConfigValueUpdateFilter = typeof ConfigValueUpdateFilter[keyof typeof ConfigValueUpdateFilter];


/**
 * 
 * @export
 * @interface ConfigurationSingle
 */
export interface ConfigurationSingle {
    /**
     * 
     * @type {FireflyConfiguration}
     * @memberof ConfigurationSingle
     */
    'data': FireflyConfiguration;
}
/**
 * 
 * @export
 * @interface ConfigurationUpdate
 */
export interface ConfigurationUpdate {
    /**
     * 
     * @type {PolymorphicProperty}
     * @memberof ConfigurationUpdate
     */
    'value': PolymorphicProperty;
}
/**
 * Mandatory when the account_role is ccAsset. Can only be monthlyFull or null.
 * @export
 * @enum {string}
 */

export const CreditCardType = {
    MonthlyFull: 'monthlyFull',
    Null: 'null'
} as const;

export type CreditCardType = typeof CreditCardType[keyof typeof CreditCardType];


/**
 * 
 * @export
 * @interface CronResult
 */
export interface CronResult {
    /**
     * 
     * @type {CronResultRow}
     * @memberof CronResult
     */
    'recurring_transactions'?: CronResultRow;
    /**
     * 
     * @type {CronResultRow}
     * @memberof CronResult
     */
    'auto_budgets'?: CronResultRow;
    /**
     * 
     * @type {CronResultRow}
     * @memberof CronResult
     */
    'telemetry'?: CronResultRow;
}
/**
 * 
 * @export
 * @interface CronResultRow
 */
export interface CronResultRow {
    /**
     * This value tells you if this specific cron job actually fired. It may not fire. Some cron jobs only fire every 24 hours, for example. 
     * @type {boolean}
     * @memberof CronResultRow
     */
    'job_fired'?: boolean | null;
    /**
     * This value tells you if this specific cron job actually did something. The job may fire but not change anything. 
     * @type {boolean}
     * @memberof CronResultRow
     */
    'job_succeeded'?: boolean | null;
    /**
     * If the cron job ran into some kind of an error, this value will be true.
     * @type {boolean}
     * @memberof CronResultRow
     */
    'job_errored'?: boolean | null;
    /**
     * If the cron job ran into some kind of an error, this value will be the error message. The success message if the job actually ran OK. 
     * @type {string}
     * @memberof CronResultRow
     */
    'message'?: string | null;
}
/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'updated_at'?: string;
    /**
     * Defaults to true
     * @type {boolean}
     * @memberof Currency
     */
    'enabled'?: boolean;
    /**
     * Make this currency the default currency.
     * @type {boolean}
     * @memberof Currency
     */
    'default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'symbol': string;
    /**
     * Supports 0-16 decimals.
     * @type {number}
     * @memberof Currency
     */
    'decimal_places'?: number;
}
/**
 * 
 * @export
 * @interface CurrencyArray
 */
export interface CurrencyArray {
    /**
     * 
     * @type {Array<CurrencyRead>}
     * @memberof CurrencyArray
     */
    'data': Array<CurrencyRead>;
    /**
     * 
     * @type {Meta}
     * @memberof CurrencyArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof CurrencyArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface CurrencyRead
 */
export interface CurrencyRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof CurrencyRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyRead
     */
    'id': string;
    /**
     * 
     * @type {Currency}
     * @memberof CurrencyRead
     */
    'attributes': Currency;
}
/**
 * 
 * @export
 * @interface CurrencySingle
 */
export interface CurrencySingle {
    /**
     * 
     * @type {CurrencyRead}
     * @memberof CurrencySingle
     */
    'data': CurrencyRead;
}
/**
 * 
 * @export
 * @interface CurrencyStore
 */
export interface CurrencyStore {
    /**
     * Defaults to true
     * @type {boolean}
     * @memberof CurrencyStore
     */
    'enabled'?: boolean;
    /**
     * Make this currency the default currency.
     * @type {boolean}
     * @memberof CurrencyStore
     */
    'default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrencyStore
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyStore
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyStore
     */
    'symbol': string;
    /**
     * Supports 0-16 decimals.
     * @type {number}
     * @memberof CurrencyStore
     */
    'decimal_places'?: number;
}
/**
 * 
 * @export
 * @interface CurrencyUpdate
 */
export interface CurrencyUpdate {
    /**
     * If the currency is enabled
     * @type {boolean}
     * @memberof CurrencyUpdate
     */
    'enabled'?: boolean;
    /**
     * If the currency must be the default for the user. You can only submit TRUE.
     * @type {boolean}
     * @memberof CurrencyUpdate
     */
    'default'?: CurrencyUpdateDefaultEnum;
    /**
     * The currency code
     * @type {string}
     * @memberof CurrencyUpdate
     */
    'code'?: string;
    /**
     * The currency name
     * @type {string}
     * @memberof CurrencyUpdate
     */
    'name'?: string;
    /**
     * The currency symbol
     * @type {string}
     * @memberof CurrencyUpdate
     */
    'symbol'?: string;
    /**
     * How many decimals to use when displaying this currency. Between 0 and 16.
     * @type {number}
     * @memberof CurrencyUpdate
     */
    'decimal_places'?: number;
}

export const CurrencyUpdateDefaultEnum = {
    True: true
} as const;

export type CurrencyUpdateDefaultEnum = typeof CurrencyUpdateDefaultEnum[keyof typeof CurrencyUpdateDefaultEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const DataDestroyObject = {
    Budgets: 'budgets',
    Bills: 'bills',
    PiggyBanks: 'piggy_banks',
    Rules: 'rules',
    Recurring: 'recurring',
    Categories: 'categories',
    Tags: 'tags',
    ObjectGroups: 'object_groups',
    Accounts: 'accounts',
    AssetAccounts: 'asset_accounts',
    ExpenseAccounts: 'expense_accounts',
    RevenueAccounts: 'revenue_accounts',
    Liabilities: 'liabilities',
    Transactions: 'transactions',
    Withdrawals: 'withdrawals',
    Deposits: 'deposits',
    Transfers: 'transfers'
} as const;

export type DataDestroyObject = typeof DataDestroyObject[keyof typeof DataDestroyObject];


/**
 * 
 * @export
 * @enum {string}
 */

export const ExportFileFilter = {
    Csv: 'csv'
} as const;

export type ExportFileFilter = typeof ExportFileFilter[keyof typeof ExportFileFilter];


/**
 * 
 * @export
 * @interface FireflyConfiguration
 */
export interface FireflyConfiguration {
    /**
     * 
     * @type {ConfigValueFilter}
     * @memberof FireflyConfiguration
     */
    'title': ConfigValueFilter;
    /**
     * 
     * @type {PolymorphicProperty}
     * @memberof FireflyConfiguration
     */
    'value': PolymorphicProperty;
    /**
     * If this config variable can be edited by the user
     * @type {boolean}
     * @memberof FireflyConfiguration
     */
    'editable': boolean;
}
/**
 * 
 * @export
 * @interface InsightGroupEntry
 */
export interface InsightGroupEntry {
    /**
     * This ID is a reference to the original object.
     * @type {string}
     * @memberof InsightGroupEntry
     */
    'id'?: string;
    /**
     * This is the name of the object.
     * @type {string}
     * @memberof InsightGroupEntry
     */
    'name'?: string;
    /**
     * The amount spent or earned between start date and end date, a number defined as a string, for this object and all asset accounts.
     * @type {string}
     * @memberof InsightGroupEntry
     */
    'difference'?: string;
    /**
     * The amount spent or earned between start date and end date, a number as a float, for this object and all asset accounts. May have rounding errors.
     * @type {number}
     * @memberof InsightGroupEntry
     */
    'difference_float'?: number;
    /**
     * The currency ID of the expenses listed for this account.
     * @type {string}
     * @memberof InsightGroupEntry
     */
    'currency_id'?: string;
    /**
     * The currency code of the expenses listed for this account.
     * @type {string}
     * @memberof InsightGroupEntry
     */
    'currency_code'?: string;
}
/**
 * 
 * @export
 * @interface InsightTotalEntry
 */
export interface InsightTotalEntry {
    /**
     * The amount spent between start date and end date, defined as a string, for this expense account and all asset accounts.
     * @type {string}
     * @memberof InsightTotalEntry
     */
    'difference'?: string;
    /**
     * The amount spent between start date and end date, defined as a string, for this expense account and all asset accounts. This number is a float (double) and may have rounding errors.
     * @type {number}
     * @memberof InsightTotalEntry
     */
    'difference_float'?: number;
    /**
     * The currency ID of the expenses listed for this expense account.
     * @type {string}
     * @memberof InsightTotalEntry
     */
    'currency_id'?: string;
    /**
     * The currency code of the expenses listed for this expense account.
     * @type {string}
     * @memberof InsightTotalEntry
     */
    'currency_code'?: string;
}
/**
 * 
 * @export
 * @interface InsightTransferEntry
 */
export interface InsightTransferEntry {
    /**
     * This ID is a reference to the original object.
     * @type {string}
     * @memberof InsightTransferEntry
     */
    'id'?: string;
    /**
     * This is the name of the object.
     * @type {string}
     * @memberof InsightTransferEntry
     */
    'name'?: string;
    /**
     * The total amount transferred between start date and end date, a number defined as a string, for this asset account.
     * @type {string}
     * @memberof InsightTransferEntry
     */
    'difference'?: string;
    /**
     * The total amount transferred between start date and end date, a number as a float, for this asset account. May have rounding errors.
     * @type {number}
     * @memberof InsightTransferEntry
     */
    'difference_float'?: number;
    /**
     * The total amount transferred TO this account between start date and end date, a number defined as a string, for this asset account.
     * @type {string}
     * @memberof InsightTransferEntry
     */
    'in'?: string;
    /**
     * The total amount transferred FROM this account between start date and end date, a number as a float, for this asset account. May have rounding errors.
     * @type {number}
     * @memberof InsightTransferEntry
     */
    'in_float'?: number;
    /**
     * The total amount transferred FROM this account between start date and end date, a number defined as a string, for this asset account.
     * @type {string}
     * @memberof InsightTransferEntry
     */
    'out'?: string;
    /**
     * The total amount transferred TO this account between start date and end date, a number as a float, for this asset account. May have rounding errors.
     * @type {number}
     * @memberof InsightTransferEntry
     */
    'out_float'?: number;
    /**
     * The currency ID of the expenses listed for this account.
     * @type {string}
     * @memberof InsightTransferEntry
     */
    'currency_id'?: string;
    /**
     * The currency code of the expenses listed for this account.
     * @type {string}
     * @memberof InsightTransferEntry
     */
    'currency_code'?: string;
}
/**
 * Mandatory when type is liability. Period over which the interest is calculated.
 * @export
 * @enum {string}
 */

export const InterestPeriod = {
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    HalfYear: 'half-year',
    Yearly: 'yearly',
    Null: 'null'
} as const;

export type InterestPeriod = typeof InterestPeriod[keyof typeof InterestPeriod];


/**
 * \'credit\' indicates somebody owes you the liability. \'debit\' Indicates you owe this debt yourself. Works only for liabiltiies.
 * @export
 * @enum {string}
 */

export const LiabilityDirection = {
    Credit: 'credit',
    Debit: 'debit',
    Null: 'null'
} as const;

export type LiabilityDirection = typeof LiabilityDirection[keyof typeof LiabilityDirection];


/**
 * Mandatory when type is liability. Specifies the exact type.
 * @export
 * @enum {string}
 */

export const LiabilityType = {
    Loan: 'loan',
    Debt: 'debt',
    Mortgage: 'mortgage',
    Null: 'null'
} as const;

export type LiabilityType = typeof LiabilityType[keyof typeof LiabilityType];


/**
 * 
 * @export
 * @interface LinkType
 */
export interface LinkType {
    /**
     * 
     * @type {string}
     * @memberof LinkType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LinkType
     */
    'inward': string;
    /**
     * 
     * @type {string}
     * @memberof LinkType
     */
    'outward': string;
    /**
     * 
     * @type {boolean}
     * @memberof LinkType
     */
    'editable'?: boolean;
}
/**
 * 
 * @export
 * @interface LinkTypeArray
 */
export interface LinkTypeArray {
    /**
     * 
     * @type {Array<LinkTypeRead>}
     * @memberof LinkTypeArray
     */
    'data': Array<LinkTypeRead>;
    /**
     * 
     * @type {Meta}
     * @memberof LinkTypeArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof LinkTypeArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface LinkTypeRead
 */
export interface LinkTypeRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof LinkTypeRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof LinkTypeRead
     */
    'id': string;
    /**
     * 
     * @type {LinkType}
     * @memberof LinkTypeRead
     */
    'attributes': LinkType;
    /**
     * 
     * @type {ObjectLink}
     * @memberof LinkTypeRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface LinkTypeSingle
 */
export interface LinkTypeSingle {
    /**
     * 
     * @type {LinkTypeRead}
     * @memberof LinkTypeSingle
     */
    'data': LinkTypeRead;
}
/**
 * 
 * @export
 * @interface LinkTypeStore
 */
export interface LinkTypeStore {
    /**
     * 
     * @type {string}
     * @memberof LinkTypeStore
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LinkTypeStore
     */
    'inward': string;
    /**
     * 
     * @type {string}
     * @memberof LinkTypeStore
     */
    'outward': string;
}
/**
 * 
 * @export
 * @interface LinkTypeUpdate
 */
export interface LinkTypeUpdate {
    /**
     * 
     * @type {string}
     * @memberof LinkTypeUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkTypeUpdate
     */
    'inward'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkTypeUpdate
     */
    'outward'?: string;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {MetaPagination}
     * @memberof Meta
     */
    'pagination'?: MetaPagination;
}
/**
 * 
 * @export
 * @interface MetaPagination
 */
export interface MetaPagination {
    /**
     * 
     * @type {number}
     * @memberof MetaPagination
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaPagination
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaPagination
     */
    'per_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaPagination
     */
    'current_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaPagination
     */
    'total_pages'?: number;
}
/**
 * 
 * @export
 * @interface ObjectGroup
 */
export interface ObjectGroup {
    /**
     * 
     * @type {string}
     * @memberof ObjectGroup
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectGroup
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectGroup
     */
    'title': string;
    /**
     * Order of the object group
     * @type {number}
     * @memberof ObjectGroup
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface ObjectGroupArray
 */
export interface ObjectGroupArray {
    /**
     * 
     * @type {Array<ObjectGroupRead>}
     * @memberof ObjectGroupArray
     */
    'data': Array<ObjectGroupRead>;
    /**
     * 
     * @type {Meta}
     * @memberof ObjectGroupArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface ObjectGroupRead
 */
export interface ObjectGroupRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof ObjectGroupRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ObjectGroupRead
     */
    'id': string;
    /**
     * 
     * @type {ObjectGroup}
     * @memberof ObjectGroupRead
     */
    'attributes': ObjectGroup;
}
/**
 * 
 * @export
 * @interface ObjectGroupSingle
 */
export interface ObjectGroupSingle {
    /**
     * 
     * @type {ObjectGroupRead}
     * @memberof ObjectGroupSingle
     */
    'data': ObjectGroupRead;
}
/**
 * 
 * @export
 * @interface ObjectGroupUpdate
 */
export interface ObjectGroupUpdate {
    /**
     * 
     * @type {string}
     * @memberof ObjectGroupUpdate
     */
    'title'?: string;
    /**
     * Order of the object group
     * @type {number}
     * @memberof ObjectGroupUpdate
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface ObjectLink
 */
export interface ObjectLink {
    /**
     * 
     * @type {ObjectLink0}
     * @memberof ObjectLink
     */
    '0'?: ObjectLink0;
    /**
     * 
     * @type {string}
     * @memberof ObjectLink
     */
    'self'?: string;
}
/**
 * 
 * @export
 * @interface ObjectLink0
 */
export interface ObjectLink0 {
    /**
     * 
     * @type {string}
     * @memberof ObjectLink0
     */
    'rel'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectLink0
     */
    'uri'?: string;
}
/**
 * 
 * @export
 * @interface PageLink
 */
export interface PageLink {
    /**
     * 
     * @type {string}
     * @memberof PageLink
     */
    'self'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLink
     */
    'first'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLink
     */
    'last'?: string;
}
/**
 * 
 * @export
 * @interface PiggyBank
 */
export interface PiggyBank {
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'updated_at'?: string;
    /**
     * The ID of the asset account this piggy bank is connected to.
     * @type {string}
     * @memberof PiggyBank
     */
    'account_id': string;
    /**
     * The name of the asset account this piggy bank is connected to.
     * @type {string}
     * @memberof PiggyBank
     */
    'account_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'currency_symbol'?: string;
    /**
     * Number of decimals supported by the currency
     * @type {number}
     * @memberof PiggyBank
     */
    'currency_decimal_places'?: number;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'target_amount': string | null;
    /**
     * 
     * @type {number}
     * @memberof PiggyBank
     */
    'percentage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'current_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'left_to_save'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'save_per_month'?: string | null;
    /**
     * The date you started with this piggy bank.
     * @type {string}
     * @memberof PiggyBank
     */
    'start_date'?: string;
    /**
     * The date you intend to finish saving money.
     * @type {string}
     * @memberof PiggyBank
     */
    'target_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PiggyBank
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PiggyBank
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PiggyBank
     */
    'notes'?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof PiggyBank
     */
    'object_group_id'?: string | null;
    /**
     * The order of the group. At least 1, for the highest sorting.
     * @type {number}
     * @memberof PiggyBank
     */
    'object_group_order'?: number | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof PiggyBank
     */
    'object_group_title'?: string | null;
}
/**
 * 
 * @export
 * @interface PiggyBankArray
 */
export interface PiggyBankArray {
    /**
     * 
     * @type {Array<PiggyBankRead>}
     * @memberof PiggyBankArray
     */
    'data': Array<PiggyBankRead>;
    /**
     * 
     * @type {Meta}
     * @memberof PiggyBankArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof PiggyBankArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface PiggyBankEvent
 */
export interface PiggyBankEvent {
    /**
     * 
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof PiggyBankEvent
     */
    'currency_decimal_places'?: number;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'amount'?: string;
    /**
     * The journal associated with the event.
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'transaction_journal_id'?: string;
    /**
     * The transaction group associated with the event.
     * @type {string}
     * @memberof PiggyBankEvent
     */
    'transaction_group_id'?: string;
}
/**
 * 
 * @export
 * @interface PiggyBankEventArray
 */
export interface PiggyBankEventArray {
    /**
     * 
     * @type {Array<PiggyBankEventRead>}
     * @memberof PiggyBankEventArray
     */
    'data': Array<PiggyBankEventRead>;
    /**
     * 
     * @type {Meta}
     * @memberof PiggyBankEventArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof PiggyBankEventArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface PiggyBankEventRead
 */
export interface PiggyBankEventRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof PiggyBankEventRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankEventRead
     */
    'id': string;
    /**
     * 
     * @type {PiggyBankEvent}
     * @memberof PiggyBankEventRead
     */
    'attributes': PiggyBankEvent;
    /**
     * 
     * @type {ObjectLink}
     * @memberof PiggyBankEventRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface PiggyBankRead
 */
export interface PiggyBankRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof PiggyBankRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankRead
     */
    'id': string;
    /**
     * 
     * @type {PiggyBank}
     * @memberof PiggyBankRead
     */
    'attributes': PiggyBank;
    /**
     * 
     * @type {ObjectLink}
     * @memberof PiggyBankRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface PiggyBankSingle
 */
export interface PiggyBankSingle {
    /**
     * 
     * @type {PiggyBankRead}
     * @memberof PiggyBankSingle
     */
    'data': PiggyBankRead;
}
/**
 * 
 * @export
 * @interface PiggyBankStore
 */
export interface PiggyBankStore {
    /**
     * 
     * @type {string}
     * @memberof PiggyBankStore
     */
    'name': string;
    /**
     * The ID of the asset account this piggy bank is connected to.
     * @type {string}
     * @memberof PiggyBankStore
     */
    'account_id': string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankStore
     */
    'target_amount': string | null;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankStore
     */
    'current_amount'?: string;
    /**
     * The date you started with this piggy bank.
     * @type {string}
     * @memberof PiggyBankStore
     */
    'start_date'?: string;
    /**
     * The date you intend to finish saving money.
     * @type {string}
     * @memberof PiggyBankStore
     */
    'target_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PiggyBankStore
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PiggyBankStore
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankStore
     */
    'notes'?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof PiggyBankStore
     */
    'object_group_id'?: string | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof PiggyBankStore
     */
    'object_group_title'?: string | null;
}
/**
 * 
 * @export
 * @interface PiggyBankUpdate
 */
export interface PiggyBankUpdate {
    /**
     * 
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'name'?: string;
    /**
     * The ID of the asset account this piggy bank is connected to.
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'account_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'currency_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'target_amount'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'current_amount'?: string;
    /**
     * The date you started with this piggy bank.
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'start_date'?: string;
    /**
     * The date you intend to finish saving money.
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'target_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PiggyBankUpdate
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PiggyBankUpdate
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'notes'?: string | null;
    /**
     * The group ID of the group this object is part of. NULL if no group.
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'object_group_id'?: string | null;
    /**
     * The name of the group. NULL if no group.
     * @type {string}
     * @memberof PiggyBankUpdate
     */
    'object_group_title'?: string | null;
}
/**
 * @type PolymorphicProperty
 * @export
 */
export type PolymorphicProperty = Array<string> | boolean | object | string;

/**
 * 
 * @export
 * @interface Preference
 */
export interface Preference {
    /**
     * 
     * @type {string}
     * @memberof Preference
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Preference
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Preference
     */
    'name': string;
    /**
     * 
     * @type {PolymorphicProperty}
     * @memberof Preference
     */
    'data': PolymorphicProperty;
}
/**
 * 
 * @export
 * @interface PreferenceArray
 */
export interface PreferenceArray {
    /**
     * 
     * @type {Array<PreferenceRead>}
     * @memberof PreferenceArray
     */
    'data': Array<PreferenceRead>;
    /**
     * 
     * @type {Meta}
     * @memberof PreferenceArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof PreferenceArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface PreferenceRead
 */
export interface PreferenceRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof PreferenceRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof PreferenceRead
     */
    'id': string;
    /**
     * 
     * @type {Preference}
     * @memberof PreferenceRead
     */
    'attributes': Preference;
}
/**
 * 
 * @export
 * @interface PreferenceSingle
 */
export interface PreferenceSingle {
    /**
     * 
     * @type {PreferenceRead}
     * @memberof PreferenceSingle
     */
    'data': PreferenceRead;
}
/**
 * 
 * @export
 * @interface PreferenceUpdate
 */
export interface PreferenceUpdate {
    /**
     * 
     * @type {PolymorphicProperty}
     * @memberof PreferenceUpdate
     */
    'data': PolymorphicProperty;
}
/**
 * 
 * @export
 * @interface Recurrence
 */
export interface Recurrence {
    /**
     * 
     * @type {string}
     * @memberof Recurrence
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Recurrence
     */
    'updated_at'?: string;
    /**
     * 
     * @type {RecurrenceTransactionType}
     * @memberof Recurrence
     */
    'type'?: RecurrenceTransactionType;
    /**
     * 
     * @type {string}
     * @memberof Recurrence
     */
    'title'?: string;
    /**
     * Not to be confused with the description of the actual transaction(s) being created.
     * @type {string}
     * @memberof Recurrence
     */
    'description'?: string;
    /**
     * First time the recurring transaction will fire. Must be after today.
     * @type {string}
     * @memberof Recurrence
     */
    'first_date'?: string;
    /**
     * Last time the recurring transaction has fired.
     * @type {string}
     * @memberof Recurrence
     */
    'latest_date'?: string | null;
    /**
     * Date until the recurring transaction can fire. Use either this field or repetitions.
     * @type {string}
     * @memberof Recurrence
     */
    'repeat_until'?: string | null;
    /**
     * Max number of created transactions. Use either this field or repeat_until.
     * @type {number}
     * @memberof Recurrence
     */
    'nr_of_repetitions'?: number | null;
    /**
     * Whether or not to fire the rules after the creation of a transaction.
     * @type {boolean}
     * @memberof Recurrence
     */
    'apply_rules'?: boolean;
    /**
     * If the recurrence is even active.
     * @type {boolean}
     * @memberof Recurrence
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Recurrence
     */
    'notes'?: string | null;
    /**
     * 
     * @type {Array<RecurrenceRepetition>}
     * @memberof Recurrence
     */
    'repetitions'?: Array<RecurrenceRepetition>;
    /**
     * 
     * @type {Array<RecurrenceTransaction>}
     * @memberof Recurrence
     */
    'transactions'?: Array<RecurrenceTransaction>;
}
/**
 * 
 * @export
 * @interface RecurrenceArray
 */
export interface RecurrenceArray {
    /**
     * 
     * @type {Array<RecurrenceRead>}
     * @memberof RecurrenceArray
     */
    'data': Array<RecurrenceRead>;
    /**
     * 
     * @type {Meta}
     * @memberof RecurrenceArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof RecurrenceArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface RecurrenceRead
 */
export interface RecurrenceRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof RecurrenceRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceRead
     */
    'id': string;
    /**
     * 
     * @type {Recurrence}
     * @memberof RecurrenceRead
     */
    'attributes': Recurrence;
    /**
     * 
     * @type {ObjectLink}
     * @memberof RecurrenceRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface RecurrenceRepetition
 */
export interface RecurrenceRepetition {
    /**
     * 
     * @type {string}
     * @memberof RecurrenceRepetition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceRepetition
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceRepetition
     */
    'updated_at'?: string;
    /**
     * 
     * @type {RecurrenceRepetitionType}
     * @memberof RecurrenceRepetition
     */
    'type': RecurrenceRepetitionType;
    /**
     * Information that defined the type of repetition. - For \'daily\', this is empty. - For \'weekly\', it is day of the week between 1 and 7 (Monday - Sunday). - For \'ndom\', it is \'1,2\' or \'4,5\' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). \'2,3\' means: the 2nd Wednesday of the month - For \'monthly\' it is the day of the month (1 - 31) - For yearly, it is a full date, ie \'2018-09-17\'. The year you use does not matter. 
     * @type {string}
     * @memberof RecurrenceRepetition
     */
    'moment': string;
    /**
     * How many occurrences to skip. 0 means skip nothing. 1 means every other.
     * @type {number}
     * @memberof RecurrenceRepetition
     */
    'skip'?: number;
    /**
     * How to respond when the recurring transaction falls in the weekend. Possible values: 1. Do nothing, just create it 2. Create no transaction. 3. Skip to the previous Friday. 4. Skip to the next Monday. 
     * @type {number}
     * @memberof RecurrenceRepetition
     */
    'weekend'?: number;
    /**
     * Auto-generated repetition description.
     * @type {string}
     * @memberof RecurrenceRepetition
     */
    'description'?: string;
    /**
     * Array of future dates when the repetition will apply to. Auto generated.
     * @type {Array<string>}
     * @memberof RecurrenceRepetition
     */
    'occurrences'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RecurrenceRepetitionStore
 */
export interface RecurrenceRepetitionStore {
    /**
     * 
     * @type {RecurrenceRepetitionType}
     * @memberof RecurrenceRepetitionStore
     */
    'type': RecurrenceRepetitionType;
    /**
     * Information that defined the type of repetition. - For \'daily\', this is empty. - For \'weekly\', it is day of the week between 1 and 7 (Monday - Sunday). - For \'ndom\', it is \'1,2\' or \'4,5\' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). \'2,3\' means: the 2nd Wednesday of the month - For \'monthly\' it is the day of the month (1 - 31) - For yearly, it is a full date, ie \'2018-09-17\'. The year you use does not matter. 
     * @type {string}
     * @memberof RecurrenceRepetitionStore
     */
    'moment': string;
    /**
     * How many occurrences to skip. 0 means skip nothing. 1 means every other.
     * @type {number}
     * @memberof RecurrenceRepetitionStore
     */
    'skip'?: number;
    /**
     * How to respond when the recurring transaction falls in the weekend. Possible values: 1. Do nothing, just create it 2. Create no transaction. 3. Skip to the previous Friday. 4. Skip to the next Monday. 
     * @type {number}
     * @memberof RecurrenceRepetitionStore
     */
    'weekend'?: number;
}
/**
 * The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week.
 * @export
 * @enum {string}
 */

export const RecurrenceRepetitionType = {
    Daily: 'daily',
    Weekly: 'weekly',
    Ndom: 'ndom',
    Monthly: 'monthly',
    Yearly: 'yearly'
} as const;

export type RecurrenceRepetitionType = typeof RecurrenceRepetitionType[keyof typeof RecurrenceRepetitionType];


/**
 * 
 * @export
 * @interface RecurrenceRepetitionUpdate
 */
export interface RecurrenceRepetitionUpdate {
    /**
     * 
     * @type {RecurrenceRepetitionType}
     * @memberof RecurrenceRepetitionUpdate
     */
    'type'?: RecurrenceRepetitionType;
    /**
     * Information that defined the type of repetition. - For \'daily\', this is empty. - For \'weekly\', it is day of the week between 1 and 7 (Monday - Sunday). - For \'ndom\', it is \'1,2\' or \'4,5\' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). \'2,3\' means: the 2nd Wednesday of the month - For \'monthly\' it is the day of the month (1 - 31) - For yearly, it is a full date, ie \'2018-09-17\'. The year you use does not matter. 
     * @type {string}
     * @memberof RecurrenceRepetitionUpdate
     */
    'moment'?: string;
    /**
     * How many occurrences to skip. 0 means skip nothing. 1 means every other.
     * @type {number}
     * @memberof RecurrenceRepetitionUpdate
     */
    'skip'?: number;
    /**
     * How to respond when the recurring transaction falls in the weekend. Possible values: 1. Do nothing, just create it 2. Create no transaction. 3. Skip to the previous Friday. 4. Skip to the next Monday. 
     * @type {number}
     * @memberof RecurrenceRepetitionUpdate
     */
    'weekend'?: number;
}
/**
 * 
 * @export
 * @interface RecurrenceSingle
 */
export interface RecurrenceSingle {
    /**
     * 
     * @type {RecurrenceRead}
     * @memberof RecurrenceSingle
     */
    'data': RecurrenceRead;
}
/**
 * 
 * @export
 * @interface RecurrenceStore
 */
export interface RecurrenceStore {
    /**
     * 
     * @type {RecurrenceTransactionType}
     * @memberof RecurrenceStore
     */
    'type': RecurrenceTransactionType;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceStore
     */
    'title': string;
    /**
     * Not to be confused with the description of the actual transaction(s) being created.
     * @type {string}
     * @memberof RecurrenceStore
     */
    'description'?: string;
    /**
     * First time the recurring transaction will fire. Must be after today.
     * @type {string}
     * @memberof RecurrenceStore
     */
    'first_date': string;
    /**
     * Date until the recurring transaction can fire. Use either this field or repetitions.
     * @type {string}
     * @memberof RecurrenceStore
     */
    'repeat_until': string | null;
    /**
     * Max number of created transactions. Use either this field or repeat_until.
     * @type {number}
     * @memberof RecurrenceStore
     */
    'nr_of_repetitions'?: number | null;
    /**
     * Whether or not to fire the rules after the creation of a transaction.
     * @type {boolean}
     * @memberof RecurrenceStore
     */
    'apply_rules'?: boolean;
    /**
     * If the recurrence is even active.
     * @type {boolean}
     * @memberof RecurrenceStore
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceStore
     */
    'notes'?: string | null;
    /**
     * 
     * @type {Array<RecurrenceRepetitionStore>}
     * @memberof RecurrenceStore
     */
    'repetitions': Array<RecurrenceRepetitionStore>;
    /**
     * 
     * @type {Array<RecurrenceTransactionStore>}
     * @memberof RecurrenceStore
     */
    'transactions': Array<RecurrenceTransactionStore>;
}
/**
 * 
 * @export
 * @interface RecurrenceTransaction
 */
export interface RecurrenceTransaction {
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'description': string;
    /**
     * Amount of the transaction.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'amount': string;
    /**
     * Foreign amount of the transaction.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'foreign_amount'?: string | null;
    /**
     * Submit either a currency_id or a currency_code.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'currency_id'?: string;
    /**
     * Submit either a currency_id or a currency_code.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'currency_symbol'?: string;
    /**
     * Number of decimals in the currency
     * @type {number}
     * @memberof RecurrenceTransaction
     */
    'currency_decimal_places'?: number;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'foreign_currency_id'?: string | null;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'foreign_currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'foreign_currency_symbol'?: string | null;
    /**
     * Number of decimals in the currency
     * @type {number}
     * @memberof RecurrenceTransaction
     */
    'foreign_currency_decimal_places'?: number | null;
    /**
     * The budget ID for this transaction.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'budget_id'?: string;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'budget_name'?: string | null;
    /**
     * Category ID for this transaction.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'category_id'?: string;
    /**
     * Category name for this transaction.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'category_name'?: string;
    /**
     * ID of the source account. Submit either this or source_name.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'source_id'?: string;
    /**
     * Name of the source account. Submit either this or source_id.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'source_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'source_iban'?: string | null;
    /**
     * 
     * @type {AccountTypeProperty}
     * @memberof RecurrenceTransaction
     */
    'source_type'?: AccountTypeProperty;
    /**
     * ID of the destination account. Submit either this or destination_name.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'destination_id'?: string;
    /**
     * Name of the destination account. Submit either this or destination_id.
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'destination_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'destination_iban'?: string | null;
    /**
     * 
     * @type {AccountTypeProperty}
     * @memberof RecurrenceTransaction
     */
    'destination_type'?: AccountTypeProperty;
    /**
     * Array of tags.
     * @type {Array<string>}
     * @memberof RecurrenceTransaction
     */
    'tags'?: Array<string> | null;
    /**
     * Optional. Use either this or the piggy_bank_name
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'piggy_bank_id'?: string | null;
    /**
     * Optional. Use either this or the piggy_bank_id
     * @type {string}
     * @memberof RecurrenceTransaction
     */
    'piggy_bank_name'?: string | null;
}
/**
 * 
 * @export
 * @interface RecurrenceTransactionStore
 */
export interface RecurrenceTransactionStore {
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'description': string;
    /**
     * Amount of the transaction.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'amount': string;
    /**
     * Foreign amount of the transaction.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'foreign_amount'?: string | null;
    /**
     * Submit either a currency_id or a currency_code.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'currency_id'?: string;
    /**
     * Submit either a currency_id or a currency_code.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'currency_code'?: string;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'foreign_currency_id'?: string | null;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'foreign_currency_code'?: string | null;
    /**
     * The budget ID for this transaction.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'budget_id'?: string;
    /**
     * Category ID for this transaction.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'category_id'?: string;
    /**
     * ID of the source account.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'source_id': string;
    /**
     * ID of the destination account.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'destination_id': string;
    /**
     * Array of tags.
     * @type {Array<string>}
     * @memberof RecurrenceTransactionStore
     */
    'tags'?: Array<string> | null;
    /**
     * Optional.
     * @type {string}
     * @memberof RecurrenceTransactionStore
     */
    'piggy_bank_id'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RecurrenceTransactionType = {
    Withdrawal: 'withdrawal',
    Transfer: 'transfer',
    Deposit: 'deposit'
} as const;

export type RecurrenceTransactionType = typeof RecurrenceTransactionType[keyof typeof RecurrenceTransactionType];


/**
 * 
 * @export
 * @interface RecurrenceTransactionUpdate
 */
export interface RecurrenceTransactionUpdate {
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'description'?: string;
    /**
     * Amount of the transaction.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'amount'?: string;
    /**
     * Foreign amount of the transaction.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'foreign_amount'?: string | null;
    /**
     * Submit either a currency_id or a currency_code.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'currency_id'?: string;
    /**
     * Submit either a currency_id or a currency_code.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'currency_code'?: string;
    /**
     * Submit either a foreign_currency_id or a foreign_currency_code, or neither.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'foreign_currency_id'?: string | null;
    /**
     * The budget ID for this transaction.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'budget_id'?: string;
    /**
     * Category ID for this transaction.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'category_id'?: string;
    /**
     * ID of the source account. Submit either this or source_name.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'source_id'?: string;
    /**
     * ID of the destination account. Submit either this or destination_name.
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'destination_id'?: string;
    /**
     * Array of tags.
     * @type {Array<string>}
     * @memberof RecurrenceTransactionUpdate
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceTransactionUpdate
     */
    'piggy_bank_id'?: string | null;
}
/**
 * 
 * @export
 * @interface RecurrenceUpdate
 */
export interface RecurrenceUpdate {
    /**
     * 
     * @type {string}
     * @memberof RecurrenceUpdate
     */
    'title'?: string;
    /**
     * Not to be confused with the description of the actual transaction(s) being created.
     * @type {string}
     * @memberof RecurrenceUpdate
     */
    'description'?: string;
    /**
     * First time the recurring transaction will fire.
     * @type {string}
     * @memberof RecurrenceUpdate
     */
    'first_date'?: string;
    /**
     * Date until the recurring transaction can fire. After that date, it\'s basically inactive. Use either this field or repetitions.
     * @type {string}
     * @memberof RecurrenceUpdate
     */
    'repeat_until'?: string | null;
    /**
     * Max number of created transactions. Use either this field or repeat_until.
     * @type {number}
     * @memberof RecurrenceUpdate
     */
    'nr_of_repetitions'?: number | null;
    /**
     * Whether or not to fire the rules after the creation of a transaction.
     * @type {boolean}
     * @memberof RecurrenceUpdate
     */
    'apply_rules'?: boolean;
    /**
     * If the recurrence is even active.
     * @type {boolean}
     * @memberof RecurrenceUpdate
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecurrenceUpdate
     */
    'notes'?: string | null;
    /**
     * 
     * @type {Array<RecurrenceRepetitionUpdate>}
     * @memberof RecurrenceUpdate
     */
    'repetitions'?: Array<RecurrenceRepetitionUpdate>;
    /**
     * 
     * @type {Array<RecurrenceTransactionUpdate>}
     * @memberof RecurrenceUpdate
     */
    'transactions'?: Array<RecurrenceTransactionUpdate>;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'description'?: string;
    /**
     * ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
     * @type {string}
     * @memberof Rule
     */
    'rule_group_id': string;
    /**
     * Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory.
     * @type {string}
     * @memberof Rule
     */
    'rule_group_title'?: string;
    /**
     * 
     * @type {number}
     * @memberof Rule
     */
    'order'?: number;
    /**
     * 
     * @type {RuleTriggerType}
     * @memberof Rule
     */
    'trigger': RuleTriggerType;
    /**
     * Whether or not the rule is even active. Default is true.
     * @type {boolean}
     * @memberof Rule
     */
    'active'?: boolean;
    /**
     * If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
     * @type {boolean}
     * @memberof Rule
     */
    'strict'?: boolean;
    /**
     * If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
     * @type {boolean}
     * @memberof Rule
     */
    'stop_processing'?: boolean;
    /**
     * 
     * @type {Array<RuleTrigger>}
     * @memberof Rule
     */
    'triggers': Array<RuleTrigger>;
    /**
     * 
     * @type {Array<RuleAction>}
     * @memberof Rule
     */
    'actions': Array<RuleAction>;
}
/**
 * 
 * @export
 * @interface RuleAction
 */
export interface RuleAction {
    /**
     * 
     * @type {string}
     * @memberof RuleAction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleAction
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleAction
     */
    'updated_at'?: string;
    /**
     * 
     * @type {RuleActionKeyword}
     * @memberof RuleAction
     */
    'type': RuleActionKeyword;
    /**
     * The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
     * @type {string}
     * @memberof RuleAction
     */
    'value': string | null;
    /**
     * Order of the action
     * @type {number}
     * @memberof RuleAction
     */
    'order'?: number;
    /**
     * If the action is active. Defaults to true.
     * @type {boolean}
     * @memberof RuleAction
     */
    'active'?: boolean;
    /**
     * When true, other actions will not be fired after this action has fired. Defaults to false.
     * @type {boolean}
     * @memberof RuleAction
     */
    'stop_processing'?: boolean;
}
/**
 * The type of thing this action will do. A limited set is possible.
 * @export
 * @enum {string}
 */

export const RuleActionKeyword = {
    UserAction: 'user_action',
    SetCategory: 'set_category',
    ClearCategory: 'clear_category',
    SetBudget: 'set_budget',
    ClearBudget: 'clear_budget',
    AddTag: 'add_tag',
    RemoveTag: 'remove_tag',
    RemoveAllTags: 'remove_all_tags',
    SetDescription: 'set_description',
    AppendDescription: 'append_description',
    PrependDescription: 'prepend_description',
    SetSourceAccount: 'set_source_account',
    SetDestinationAccount: 'set_destination_account',
    SetNotes: 'set_notes',
    AppendNotes: 'append_notes',
    PrependNotes: 'prepend_notes',
    ClearNotes: 'clear_notes',
    LinkToBill: 'link_to_bill',
    ConvertWithdrawal: 'convert_withdrawal',
    ConvertDeposit: 'convert_deposit',
    ConvertTransfer: 'convert_transfer',
    DeleteTransaction: 'delete_transaction'
} as const;

export type RuleActionKeyword = typeof RuleActionKeyword[keyof typeof RuleActionKeyword];


/**
 * 
 * @export
 * @interface RuleActionStore
 */
export interface RuleActionStore {
    /**
     * 
     * @type {RuleActionKeyword}
     * @memberof RuleActionStore
     */
    'type': RuleActionKeyword;
    /**
     * The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
     * @type {string}
     * @memberof RuleActionStore
     */
    'value': string | null;
    /**
     * Order of the action
     * @type {number}
     * @memberof RuleActionStore
     */
    'order'?: number;
    /**
     * If the action is active. Defaults to true.
     * @type {boolean}
     * @memberof RuleActionStore
     */
    'active'?: boolean;
    /**
     * When true, other actions will not be fired after this action has fired. Defaults to false.
     * @type {boolean}
     * @memberof RuleActionStore
     */
    'stop_processing'?: boolean;
}
/**
 * 
 * @export
 * @interface RuleActionUpdate
 */
export interface RuleActionUpdate {
    /**
     * 
     * @type {RuleActionKeyword}
     * @memberof RuleActionUpdate
     */
    'type'?: RuleActionKeyword;
    /**
     * The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory.
     * @type {string}
     * @memberof RuleActionUpdate
     */
    'value'?: string | null;
    /**
     * Order of the action
     * @type {number}
     * @memberof RuleActionUpdate
     */
    'order'?: number;
    /**
     * If the action is active.
     * @type {boolean}
     * @memberof RuleActionUpdate
     */
    'active'?: boolean;
    /**
     * When true, other actions will not be fired after this action has fired.
     * @type {boolean}
     * @memberof RuleActionUpdate
     */
    'stop_processing'?: boolean;
}
/**
 * 
 * @export
 * @interface RuleArray
 */
export interface RuleArray {
    /**
     * 
     * @type {Array<RuleRead>}
     * @memberof RuleArray
     */
    'data': Array<RuleRead>;
    /**
     * 
     * @type {Meta}
     * @memberof RuleArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof RuleArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface RuleGroup
 */
export interface RuleGroup {
    /**
     * 
     * @type {string}
     * @memberof RuleGroup
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleGroup
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleGroup
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RuleGroup
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RuleGroup
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RuleGroup
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface RuleGroupArray
 */
export interface RuleGroupArray {
    /**
     * 
     * @type {Array<RuleGroupRead>}
     * @memberof RuleGroupArray
     */
    'data': Array<RuleGroupRead>;
    /**
     * 
     * @type {Meta}
     * @memberof RuleGroupArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof RuleGroupArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface RuleGroupRead
 */
export interface RuleGroupRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof RuleGroupRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof RuleGroupRead
     */
    'id': string;
    /**
     * 
     * @type {RuleGroup}
     * @memberof RuleGroupRead
     */
    'attributes': RuleGroup;
    /**
     * 
     * @type {ObjectLink}
     * @memberof RuleGroupRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface RuleGroupSingle
 */
export interface RuleGroupSingle {
    /**
     * 
     * @type {RuleGroupRead}
     * @memberof RuleGroupSingle
     */
    'data': RuleGroupRead;
}
/**
 * 
 * @export
 * @interface RuleGroupStore
 */
export interface RuleGroupStore {
    /**
     * 
     * @type {string}
     * @memberof RuleGroupStore
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RuleGroupStore
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RuleGroupStore
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RuleGroupStore
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface RuleGroupUpdate
 */
export interface RuleGroupUpdate {
    /**
     * 
     * @type {string}
     * @memberof RuleGroupUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleGroupUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RuleGroupUpdate
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RuleGroupUpdate
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface RuleRead
 */
export interface RuleRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof RuleRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof RuleRead
     */
    'id': string;
    /**
     * 
     * @type {Rule}
     * @memberof RuleRead
     */
    'attributes': Rule;
    /**
     * 
     * @type {ObjectLink}
     * @memberof RuleRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface RuleSingle
 */
export interface RuleSingle {
    /**
     * 
     * @type {RuleRead}
     * @memberof RuleSingle
     */
    'data': RuleRead;
}
/**
 * 
 * @export
 * @interface RuleStore
 */
export interface RuleStore {
    /**
     * 
     * @type {string}
     * @memberof RuleStore
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof RuleStore
     */
    'description'?: string;
    /**
     * ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
     * @type {string}
     * @memberof RuleStore
     */
    'rule_group_id': string;
    /**
     * Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory.
     * @type {string}
     * @memberof RuleStore
     */
    'rule_group_title'?: string;
    /**
     * 
     * @type {number}
     * @memberof RuleStore
     */
    'order'?: number;
    /**
     * 
     * @type {RuleTriggerType}
     * @memberof RuleStore
     */
    'trigger': RuleTriggerType;
    /**
     * Whether or not the rule is even active. Default is true.
     * @type {boolean}
     * @memberof RuleStore
     */
    'active'?: boolean;
    /**
     * If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
     * @type {boolean}
     * @memberof RuleStore
     */
    'strict'?: boolean;
    /**
     * If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
     * @type {boolean}
     * @memberof RuleStore
     */
    'stop_processing'?: boolean;
    /**
     * 
     * @type {Array<RuleTriggerStore>}
     * @memberof RuleStore
     */
    'triggers': Array<RuleTriggerStore>;
    /**
     * 
     * @type {Array<RuleActionStore>}
     * @memberof RuleStore
     */
    'actions': Array<RuleActionStore>;
}
/**
 * 
 * @export
 * @interface RuleTrigger
 */
export interface RuleTrigger {
    /**
     * 
     * @type {string}
     * @memberof RuleTrigger
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTrigger
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTrigger
     */
    'updated_at'?: string;
    /**
     * 
     * @type {RuleTriggerKeyword}
     * @memberof RuleTrigger
     */
    'type': RuleTriggerKeyword;
    /**
     * The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
     * @type {string}
     * @memberof RuleTrigger
     */
    'value': string;
    /**
     * Order of the trigger
     * @type {number}
     * @memberof RuleTrigger
     */
    'order'?: number;
    /**
     * If the trigger is active. Defaults to true.
     * @type {boolean}
     * @memberof RuleTrigger
     */
    'active'?: boolean;
    /**
     * When true, other triggers will not be checked if this trigger was triggered. Defaults to false.
     * @type {boolean}
     * @memberof RuleTrigger
     */
    'stop_processing'?: boolean;
}
/**
 * The type of thing this trigger responds to. A limited set is possible
 * @export
 * @enum {string}
 */

export const RuleTriggerKeyword = {
    FromAccountStarts: 'from_account_starts',
    FromAccountEnds: 'from_account_ends',
    FromAccountIs: 'from_account_is',
    FromAccountContains: 'from_account_contains',
    ToAccountStarts: 'to_account_starts',
    ToAccountEnds: 'to_account_ends',
    ToAccountIs: 'to_account_is',
    ToAccountContains: 'to_account_contains',
    AmountLess: 'amount_less',
    AmountExactly: 'amount_exactly',
    AmountMore: 'amount_more',
    DescriptionStarts: 'description_starts',
    DescriptionEnds: 'description_ends',
    DescriptionContains: 'description_contains',
    DescriptionIs: 'description_is',
    TransactionType: 'transaction_type',
    CategoryIs: 'category_is',
    BudgetIs: 'budget_is',
    TagIs: 'tag_is',
    CurrencyIs: 'currency_is',
    HasAttachments: 'has_attachments',
    HasNoCategory: 'has_no_category',
    HasAnyCategory: 'has_any_category',
    HasNoBudget: 'has_no_budget',
    HasAnyBudget: 'has_any_budget',
    HasNoTag: 'has_no_tag',
    HasAnyTag: 'has_any_tag',
    NotesContain: 'notes_contain',
    NotesStart: 'notes_start',
    NotesEnd: 'notes_end',
    NotesAre: 'notes_are',
    NoNotes: 'no_notes',
    AnyNotes: 'any_notes',
    SourceAccountIs: 'source_account_is',
    DestinationAccountIs: 'destination_account_is',
    SourceAccountStarts: 'source_account_starts'
} as const;

export type RuleTriggerKeyword = typeof RuleTriggerKeyword[keyof typeof RuleTriggerKeyword];


/**
 * 
 * @export
 * @interface RuleTriggerStore
 */
export interface RuleTriggerStore {
    /**
     * 
     * @type {RuleTriggerKeyword}
     * @memberof RuleTriggerStore
     */
    'type': RuleTriggerKeyword;
    /**
     * The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
     * @type {string}
     * @memberof RuleTriggerStore
     */
    'value': string;
    /**
     * Order of the trigger
     * @type {number}
     * @memberof RuleTriggerStore
     */
    'order'?: number;
    /**
     * If the trigger is active. Defaults to true.
     * @type {boolean}
     * @memberof RuleTriggerStore
     */
    'active'?: boolean;
    /**
     * When true, other triggers will not be checked if this trigger was triggered. Defaults to false.
     * @type {boolean}
     * @memberof RuleTriggerStore
     */
    'stop_processing'?: boolean;
}
/**
 * Which action is necessary for the rule to fire? Use either store-journal or update-journal.
 * @export
 * @enum {string}
 */

export const RuleTriggerType = {
    StoreJournal: 'store-journal',
    UpdateJournal: 'update-journal'
} as const;

export type RuleTriggerType = typeof RuleTriggerType[keyof typeof RuleTriggerType];


/**
 * 
 * @export
 * @interface RuleTriggerUpdate
 */
export interface RuleTriggerUpdate {
    /**
     * 
     * @type {RuleTriggerKeyword}
     * @memberof RuleTriggerUpdate
     */
    'type'?: RuleTriggerKeyword;
    /**
     * The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger.
     * @type {string}
     * @memberof RuleTriggerUpdate
     */
    'value'?: string;
    /**
     * Order of the trigger
     * @type {number}
     * @memberof RuleTriggerUpdate
     */
    'order'?: number;
    /**
     * If the trigger is active.
     * @type {boolean}
     * @memberof RuleTriggerUpdate
     */
    'active'?: boolean;
    /**
     * When true, other triggers will not be checked if this trigger was triggered.
     * @type {boolean}
     * @memberof RuleTriggerUpdate
     */
    'stop_processing'?: boolean;
}
/**
 * 
 * @export
 * @interface RuleUpdate
 */
export interface RuleUpdate {
    /**
     * 
     * @type {string}
     * @memberof RuleUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleUpdate
     */
    'description'?: string;
    /**
     * ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory.
     * @type {string}
     * @memberof RuleUpdate
     */
    'rule_group_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof RuleUpdate
     */
    'order'?: number;
    /**
     * 
     * @type {RuleTriggerType}
     * @memberof RuleUpdate
     */
    'trigger'?: RuleTriggerType;
    /**
     * Whether or not the rule is even active. Default is true.
     * @type {boolean}
     * @memberof RuleUpdate
     */
    'active'?: boolean;
    /**
     * If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true.
     * @type {boolean}
     * @memberof RuleUpdate
     */
    'strict'?: boolean;
    /**
     * If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false.
     * @type {boolean}
     * @memberof RuleUpdate
     */
    'stop_processing'?: boolean;
    /**
     * 
     * @type {Array<RuleTriggerUpdate>}
     * @memberof RuleUpdate
     */
    'triggers'?: Array<RuleTriggerUpdate>;
    /**
     * 
     * @type {Array<RuleActionUpdate>}
     * @memberof RuleUpdate
     */
    'actions'?: Array<RuleActionUpdate>;
}
/**
 * Can only be one one these account types. import, initial-balance and reconciliation cannot be set manually.
 * @export
 * @enum {string}
 */

export const ShortAccountTypeProperty = {
    Asset: 'asset',
    Expense: 'expense',
    Import: 'import',
    Revenue: 'revenue',
    Cash: 'cash',
    Liability: 'liability',
    Liabilities: 'liabilities',
    InitialBalance: 'initial-balance',
    Reconciliation: 'reconciliation'
} as const;

export type ShortAccountTypeProperty = typeof ShortAccountTypeProperty[keyof typeof ShortAccountTypeProperty];


/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {SystemInfoData}
     * @memberof SystemInfo
     */
    'data': SystemInfoData;
}
/**
 * 
 * @export
 * @interface SystemInfoData
 */
export interface SystemInfoData {
    /**
     * 
     * @type {string}
     * @memberof SystemInfoData
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfoData
     */
    'api_version': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfoData
     */
    'php_version': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfoData
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfoData
     */
    'driver': string;
}
/**
 * 
 * @export
 * @interface TagArray
 */
export interface TagArray {
    /**
     * 
     * @type {Array<TagRead>}
     * @memberof TagArray
     */
    'data': Array<TagRead>;
    /**
     * 
     * @type {Meta}
     * @memberof TagArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof TagArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface TagModel
 */
export interface TagModel {
    /**
     * 
     * @type {string}
     * @memberof TagModel
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TagModel
     */
    'updated_at'?: string;
    /**
     * The tag
     * @type {string}
     * @memberof TagModel
     */
    'tag': string;
    /**
     * The date to which the tag is applicable.
     * @type {string}
     * @memberof TagModel
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagModel
     */
    'description'?: string | null;
    /**
     * Latitude of the tag\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TagModel
     */
    'latitude'?: number | null;
    /**
     * Latitude of the tag\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TagModel
     */
    'longitude'?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     * @type {number}
     * @memberof TagModel
     */
    'zoom_level'?: number | null;
}
/**
 * 
 * @export
 * @interface TagModelStore
 */
export interface TagModelStore {
    /**
     * The tag
     * @type {string}
     * @memberof TagModelStore
     */
    'tag': string;
    /**
     * The date to which the tag is applicable.
     * @type {string}
     * @memberof TagModelStore
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagModelStore
     */
    'description'?: string | null;
    /**
     * Latitude of the tag\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TagModelStore
     */
    'latitude'?: number | null;
    /**
     * Latitude of the tag\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TagModelStore
     */
    'longitude'?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     * @type {number}
     * @memberof TagModelStore
     */
    'zoom_level'?: number | null;
}
/**
 * 
 * @export
 * @interface TagModelUpdate
 */
export interface TagModelUpdate {
    /**
     * The tag
     * @type {string}
     * @memberof TagModelUpdate
     */
    'tag'?: string;
    /**
     * The date to which the tag is applicable.
     * @type {string}
     * @memberof TagModelUpdate
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagModelUpdate
     */
    'description'?: string | null;
    /**
     * Latitude of the tag\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TagModelUpdate
     */
    'latitude'?: number | null;
    /**
     * Latitude of the tag\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TagModelUpdate
     */
    'longitude'?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     * @type {number}
     * @memberof TagModelUpdate
     */
    'zoom_level'?: number | null;
}
/**
 * 
 * @export
 * @interface TagRead
 */
export interface TagRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof TagRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TagRead
     */
    'id': string;
    /**
     * 
     * @type {TagModel}
     * @memberof TagRead
     */
    'attributes': TagModel;
    /**
     * 
     * @type {ObjectLink}
     * @memberof TagRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface TagSingle
 */
export interface TagSingle {
    /**
     * 
     * @type {TagRead}
     * @memberof TagSingle
     */
    'data': TagRead;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'updated_at'?: string;
    /**
     * User ID
     * @type {string}
     * @memberof Transaction
     */
    'user'?: string;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     * @type {string}
     * @memberof Transaction
     */
    'group_title'?: string | null;
    /**
     * 
     * @type {Array<TransactionSplit>}
     * @memberof Transaction
     */
    'transactions': Array<TransactionSplit>;
}
/**
 * 
 * @export
 * @interface TransactionArray
 */
export interface TransactionArray {
    /**
     * 
     * @type {Array<TransactionRead>}
     * @memberof TransactionArray
     */
    'data': Array<TransactionRead>;
    /**
     * 
     * @type {Meta}
     * @memberof TransactionArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof TransactionArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface TransactionLink
 */
export interface TransactionLink {
    /**
     * 
     * @type {string}
     * @memberof TransactionLink
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLink
     */
    'updated_at'?: string;
    /**
     * The link type ID to use. You can also use the link_type_name field.
     * @type {string}
     * @memberof TransactionLink
     */
    'link_type_id': string;
    /**
     * The link type name to use. You can also use the link_type_id field.
     * @type {string}
     * @memberof TransactionLink
     */
    'link_type_name'?: string;
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the \'is paid by\' transaction of the set.
     * @type {string}
     * @memberof TransactionLink
     */
    'inward_id': string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the \'pays for\' transaction of the set.
     * @type {string}
     * @memberof TransactionLink
     */
    'outward_id': string;
    /**
     * Optional. Some notes.
     * @type {string}
     * @memberof TransactionLink
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionLinkArray
 */
export interface TransactionLinkArray {
    /**
     * 
     * @type {Array<TransactionLinkRead>}
     * @memberof TransactionLinkArray
     */
    'data': Array<TransactionLinkRead>;
    /**
     * 
     * @type {Meta}
     * @memberof TransactionLinkArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof TransactionLinkArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface TransactionLinkRead
 */
export interface TransactionLinkRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof TransactionLinkRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLinkRead
     */
    'id': string;
    /**
     * 
     * @type {TransactionLink}
     * @memberof TransactionLinkRead
     */
    'attributes': TransactionLink;
    /**
     * 
     * @type {ObjectLink}
     * @memberof TransactionLinkRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface TransactionLinkSingle
 */
export interface TransactionLinkSingle {
    /**
     * 
     * @type {TransactionLinkRead}
     * @memberof TransactionLinkSingle
     */
    'data': TransactionLinkRead;
}
/**
 * 
 * @export
 * @interface TransactionLinkStore
 */
export interface TransactionLinkStore {
    /**
     * The link type ID to use. You can also use the link_type_name field.
     * @type {string}
     * @memberof TransactionLinkStore
     */
    'link_type_id': string;
    /**
     * The link type name to use. You can also use the link_type_id field.
     * @type {string}
     * @memberof TransactionLinkStore
     */
    'link_type_name'?: string;
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the \'is paid by\' transaction of the set.
     * @type {string}
     * @memberof TransactionLinkStore
     */
    'inward_id': string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the \'pays for\' transaction of the set.
     * @type {string}
     * @memberof TransactionLinkStore
     */
    'outward_id': string;
    /**
     * Optional. Some notes.
     * @type {string}
     * @memberof TransactionLinkStore
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionLinkUpdate
 */
export interface TransactionLinkUpdate {
    /**
     * The link type ID to use. Use this field OR use the link_type_name field.
     * @type {string}
     * @memberof TransactionLinkUpdate
     */
    'link_type_id'?: string;
    /**
     * The link type name to use. Use this field OR use the link_type_id field.
     * @type {string}
     * @memberof TransactionLinkUpdate
     */
    'link_type_name'?: string;
    /**
     * The inward transaction transaction_journal_id for the link. This becomes the \'is paid by\' transaction of the set.
     * @type {string}
     * @memberof TransactionLinkUpdate
     */
    'inward_id'?: string;
    /**
     * The outward transaction transaction_journal_id for the link. This becomes the \'pays for\' transaction of the set.
     * @type {string}
     * @memberof TransactionLinkUpdate
     */
    'outward_id'?: string;
    /**
     * Optional. Some notes. If you submit an empty string the current notes will be removed
     * @type {string}
     * @memberof TransactionLinkUpdate
     */
    'notes'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionRead
 */
export interface TransactionRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof TransactionRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'id': string;
    /**
     * 
     * @type {Transaction}
     * @memberof TransactionRead
     */
    'attributes': Transaction;
    /**
     * 
     * @type {ObjectLink}
     * @memberof TransactionRead
     */
    'links': ObjectLink;
}
/**
 * 
 * @export
 * @interface TransactionSingle
 */
export interface TransactionSingle {
    /**
     * 
     * @type {TransactionRead}
     * @memberof TransactionSingle
     */
    'data': TransactionRead;
}
/**
 * 
 * @export
 * @interface TransactionSplit
 */
export interface TransactionSplit {
    /**
     * User ID
     * @type {string}
     * @memberof TransactionSplit
     */
    'user'?: string;
    /**
     * ID of the underlying transaction journal. Each transaction consists of a transaction group (see the top ID) and one or more journals making up the splits of the transaction. 
     * @type {string}
     * @memberof TransactionSplit
     */
    'transaction_journal_id'?: string;
    /**
     * 
     * @type {TransactionTypeProperty}
     * @memberof TransactionSplit
     */
    'type': TransactionTypeProperty;
    /**
     * Date of the transaction
     * @type {string}
     * @memberof TransactionSplit
     */
    'date': string;
    /**
     * Order of this entry in the list of transactions.
     * @type {number}
     * @memberof TransactionSplit
     */
    'order'?: number | null;
    /**
     * Currency ID. Default is the source account\'s currency, or the user\'s default currency. Can be used instead of currency_code.
     * @type {string}
     * @memberof TransactionSplit
     */
    'currency_id'?: string | null;
    /**
     * Currency code. Default is the source account\'s currency, or the user\'s default currency. Can be used instead of currency_id.
     * @type {string}
     * @memberof TransactionSplit
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'currency_name'?: string;
    /**
     * Number of decimals used in this currency.
     * @type {number}
     * @memberof TransactionSplit
     */
    'currency_decimal_places'?: number;
    /**
     * Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
     * @type {string}
     * @memberof TransactionSplit
     */
    'foreign_currency_id'?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
     * @type {string}
     * @memberof TransactionSplit
     */
    'foreign_currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'foreign_currency_symbol'?: string | null;
    /**
     * Number of decimals in the currency
     * @type {number}
     * @memberof TransactionSplit
     */
    'foreign_currency_decimal_places'?: number | null;
    /**
     * Amount of the transaction.
     * @type {string}
     * @memberof TransactionSplit
     */
    'amount': string;
    /**
     * The amount in a foreign currency.
     * @type {string}
     * @memberof TransactionSplit
     */
    'foreign_amount'?: string | null;
    /**
     * Description of the transaction.
     * @type {string}
     * @memberof TransactionSplit
     */
    'description': string;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     * @type {string}
     * @memberof TransactionSplit
     */
    'source_id': string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     * @type {string}
     * @memberof TransactionSplit
     */
    'source_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'source_iban'?: string | null;
    /**
     * 
     * @type {AccountTypeProperty}
     * @memberof TransactionSplit
     */
    'source_type'?: AccountTypeProperty;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     * @type {string}
     * @memberof TransactionSplit
     */
    'destination_id': string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     * @type {string}
     * @memberof TransactionSplit
     */
    'destination_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'destination_iban'?: string | null;
    /**
     * 
     * @type {AccountTypeProperty}
     * @memberof TransactionSplit
     */
    'destination_type'?: AccountTypeProperty;
    /**
     * The budget ID for this transaction.
     * @type {string}
     * @memberof TransactionSplit
     */
    'budget_id'?: string | null;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     * @type {string}
     * @memberof TransactionSplit
     */
    'budget_name'?: string | null;
    /**
     * The category ID for this transaction.
     * @type {string}
     * @memberof TransactionSplit
     */
    'category_id'?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     * @type {string}
     * @memberof TransactionSplit
     */
    'category_name'?: string | null;
    /**
     * Optional. Use either this or the bill_name
     * @type {string}
     * @memberof TransactionSplit
     */
    'bill_id'?: string | null;
    /**
     * Optional. Use either this or the bill_id
     * @type {string}
     * @memberof TransactionSplit
     */
    'bill_name'?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     * @type {boolean}
     * @memberof TransactionSplit
     */
    'reconciled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'notes'?: string | null;
    /**
     * Array of tags.
     * @type {Array<string>}
     * @memberof TransactionSplit
     */
    'tags'?: Array<string> | null;
    /**
     * Reference to internal reference of other systems.
     * @type {string}
     * @memberof TransactionSplit
     */
    'internal_reference'?: string | null;
    /**
     * Reference to external ID in other systems.
     * @type {string}
     * @memberof TransactionSplit
     */
    'external_id'?: string | null;
    /**
     * External, custom URL for this transaction.
     * @type {string}
     * @memberof TransactionSplit
     */
    'external_url'?: string | null;
    /**
     * System generated identifier for original creator of transaction.
     * @type {string}
     * @memberof TransactionSplit
     */
    'original_source'?: string | null;
    /**
     * Reference to recurrence that made the transaction.
     * @type {number}
     * @memberof TransactionSplit
     */
    'recurrence_id'?: number | null;
    /**
     * Total number of transactions expected to be created by this recurrence repetition. Will be 0 if infinite.
     * @type {number}
     * @memberof TransactionSplit
     */
    'recurrence_total'?: number | null;
    /**
     * The # of the current transaction created under this recurrence.
     * @type {number}
     * @memberof TransactionSplit
     */
    'recurrence_count'?: number | null;
    /**
     * Internal ID of bunq transaction. DEPRECATED
     * @type {string}
     * @memberof TransactionSplit
     */
    'bunq_payment_id'?: string | null;
    /**
     * Hash value of original import transaction (for duplicate detection).
     * @type {string}
     * @memberof TransactionSplit
     */
    'import_hash_v2'?: string | null;
    /**
     * SEPA Clearing Code
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_cc'?: string | null;
    /**
     * SEPA Opposing Account Identifier
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_ct_op'?: string | null;
    /**
     * SEPA end-to-end Identifier
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_ct_id'?: string | null;
    /**
     * SEPA mandate identifier
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_db'?: string | null;
    /**
     * SEPA Country
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_country'?: string | null;
    /**
     * SEPA External Purpose indicator
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_ep'?: string | null;
    /**
     * SEPA Creditor Identifier
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_ci'?: string | null;
    /**
     * SEPA Batch ID
     * @type {string}
     * @memberof TransactionSplit
     */
    'sepa_batch_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'interest_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'book_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'process_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'due_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'payment_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplit
     */
    'invoice_date'?: string | null;
    /**
     * Latitude of the transaction\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TransactionSplit
     */
    'latitude'?: number | null;
    /**
     * Latitude of the transaction\'s location, if applicable. Can be used to draw a map.
     * @type {number}
     * @memberof TransactionSplit
     */
    'longitude'?: number | null;
    /**
     * Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels.
     * @type {number}
     * @memberof TransactionSplit
     */
    'zoom_level'?: number | null;
    /**
     * If the transaction has attachments.
     * @type {boolean}
     * @memberof TransactionSplit
     */
    'has_attachments'?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionSplitStore
 */
export interface TransactionSplitStore {
    /**
     * 
     * @type {TransactionTypeProperty}
     * @memberof TransactionSplitStore
     */
    'type': TransactionTypeProperty;
    /**
     * Date of the transaction
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'date': string;
    /**
     * Amount of the transaction.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'amount': string;
    /**
     * Description of the transaction.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'description': string;
    /**
     * Order of this entry in the list of transactions.
     * @type {number}
     * @memberof TransactionSplitStore
     */
    'order'?: number | null;
    /**
     * Currency ID. Default is the source account\'s currency, or the user\'s default currency. The value you submit may be overruled by the source or destination account.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'currency_id'?: string | null;
    /**
     * Currency code. Default is the source account\'s currency, or the user\'s default currency. The value you submit may be overruled by the source or destination account.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'currency_code'?: string | null;
    /**
     * The amount in a foreign currency.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'foreign_amount'?: string | null;
    /**
     * Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'foreign_currency_id'?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'foreign_currency_code'?: string | null;
    /**
     * The budget ID for this transaction.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'budget_id'?: string | null;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'budget_name'?: string | null;
    /**
     * The category ID for this transaction.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'category_id'?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'category_name'?: string | null;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'source_id'?: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'source_name'?: string | null;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'destination_id'?: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'destination_name'?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     * @type {boolean}
     * @memberof TransactionSplitStore
     */
    'reconciled'?: boolean;
    /**
     * Optional. Use either this or the piggy_bank_name
     * @type {number}
     * @memberof TransactionSplitStore
     */
    'piggy_bank_id'?: number;
    /**
     * Optional. Use either this or the piggy_bank_id
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'piggy_bank_name'?: string;
    /**
     * Optional. Use either this or the bill_name
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'bill_id'?: string | null;
    /**
     * Optional. Use either this or the bill_id
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'bill_name'?: string | null;
    /**
     * Array of tags.
     * @type {Array<string>}
     * @memberof TransactionSplitStore
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'notes'?: string | null;
    /**
     * Reference to internal reference of other systems.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'internal_reference'?: string | null;
    /**
     * Reference to external ID in other systems.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'external_id'?: string | null;
    /**
     * External, custom URL for this transaction.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'external_url'?: string | null;
    /**
     * Internal ID of bunq transaction. Field is no longer used but still works.
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'bunq_payment_id'?: string | null;
    /**
     * SEPA Clearing Code
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_cc'?: string | null;
    /**
     * SEPA Opposing Account Identifier
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_ct_op'?: string | null;
    /**
     * SEPA end-to-end Identifier
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_ct_id'?: string | null;
    /**
     * SEPA mandate identifier
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_db'?: string | null;
    /**
     * SEPA Country
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_country'?: string | null;
    /**
     * SEPA External Purpose indicator
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_ep'?: string | null;
    /**
     * SEPA Creditor Identifier
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_ci'?: string | null;
    /**
     * SEPA Batch ID
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'sepa_batch_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'interest_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'book_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'process_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'due_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'payment_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitStore
     */
    'invoice_date'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionSplitUpdate
 */
export interface TransactionSplitUpdate {
    /**
     * Date of the transaction
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'date'?: string;
    /**
     * Amount of the transaction.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'amount'?: string;
    /**
     * Description of the transaction.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'description'?: string;
    /**
     * Order of this entry in the list of transactions.
     * @type {number}
     * @memberof TransactionSplitUpdate
     */
    'order'?: number | null;
    /**
     * Currency ID. Default is the source account\'s currency, or the user\'s default currency. Can be used instead of currency_code.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'currency_id'?: string | null;
    /**
     * Currency code. Default is the source account\'s currency, or the user\'s default currency. Can be used instead of currency_id.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'currency_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'currency_name'?: string;
    /**
     * Number of decimals used in this currency.
     * @type {number}
     * @memberof TransactionSplitUpdate
     */
    'currency_decimal_places'?: number;
    /**
     * The amount in a foreign currency.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'foreign_amount'?: string | null;
    /**
     * Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'foreign_currency_id'?: string | null;
    /**
     * Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'foreign_currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'foreign_currency_symbol'?: string | null;
    /**
     * Number of decimals in the currency
     * @type {number}
     * @memberof TransactionSplitUpdate
     */
    'foreign_currency_decimal_places'?: number | null;
    /**
     * The budget ID for this transaction.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'budget_id'?: string | null;
    /**
     * The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'budget_name'?: string | null;
    /**
     * The category ID for this transaction.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'category_id'?: string | null;
    /**
     * The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'category_name'?: string | null;
    /**
     * ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'source_id'?: string | null;
    /**
     * Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'source_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'source_iban'?: string | null;
    /**
     * ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'destination_id'?: string | null;
    /**
     * Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'destination_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'destination_iban'?: string | null;
    /**
     * If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user.
     * @type {boolean}
     * @memberof TransactionSplitUpdate
     */
    'reconciled'?: boolean;
    /**
     * Optional. Use either this or the bill_name
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'bill_id'?: string | null;
    /**
     * Optional. Use either this or the bill_id
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'bill_name'?: string | null;
    /**
     * Array of tags.
     * @type {Array<string>}
     * @memberof TransactionSplitUpdate
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'notes'?: string | null;
    /**
     * Reference to internal reference of other systems.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'internal_reference'?: string | null;
    /**
     * Reference to external ID in other systems.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'external_id'?: string | null;
    /**
     * External, custom URL for this transaction.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'external_url'?: string | null;
    /**
     * Internal ID of bunq transaction.
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'bunq_payment_id'?: string | null;
    /**
     * SEPA Clearing Code
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_cc'?: string | null;
    /**
     * SEPA Opposing Account Identifier
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_ct_op'?: string | null;
    /**
     * SEPA end-to-end Identifier
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_ct_id'?: string | null;
    /**
     * SEPA mandate identifier
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_db'?: string | null;
    /**
     * SEPA Country
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_country'?: string | null;
    /**
     * SEPA External Purpose indicator
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_ep'?: string | null;
    /**
     * SEPA Creditor Identifier
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_ci'?: string | null;
    /**
     * SEPA Batch ID
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'sepa_batch_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'interest_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'book_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'process_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'due_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'payment_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionSplitUpdate
     */
    'invoice_date'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionStore
 */
export interface TransactionStore {
    /**
     * Break if the submitted transaction exists already.
     * @type {boolean}
     * @memberof TransactionStore
     */
    'error_if_duplicate_hash'?: boolean;
    /**
     * Whether or not to apply rules when submitting transaction.
     * @type {boolean}
     * @memberof TransactionStore
     */
    'apply_rules'?: boolean;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     * @type {boolean}
     * @memberof TransactionStore
     */
    'fire_webhooks'?: boolean;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     * @type {string}
     * @memberof TransactionStore
     */
    'group_title'?: string | null;
    /**
     * 
     * @type {Array<TransactionSplitStore>}
     * @memberof TransactionStore
     */
    'transactions': Array<TransactionSplitStore>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionTypeFilter = {
    All: 'all',
    Withdrawal: 'withdrawal',
    Withdrawals: 'withdrawals',
    Expense: 'expense',
    Deposit: 'deposit',
    Deposits: 'deposits',
    Income: 'income',
    Transfer: 'transfer',
    Transfers: 'transfers',
    OpeningBalance: 'opening_balance',
    Reconciliation: 'reconciliation',
    Special: 'special',
    Specials: 'specials',
    Default: 'default'
} as const;

export type TransactionTypeFilter = typeof TransactionTypeFilter[keyof typeof TransactionTypeFilter];


/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionTypeProperty = {
    Withdrawal: 'withdrawal',
    Deposit: 'deposit',
    Transfer: 'transfer',
    Reconciliation: 'reconciliation',
    OpeningBalance: 'opening balance'
} as const;

export type TransactionTypeProperty = typeof TransactionTypeProperty[keyof typeof TransactionTypeProperty];


/**
 * 
 * @export
 * @interface TransactionUpdate
 */
export interface TransactionUpdate {
    /**
     * Whether or not to apply rules when submitting transaction.
     * @type {boolean}
     * @memberof TransactionUpdate
     */
    'apply_rules'?: boolean;
    /**
     * Whether or not to fire the webhooks that are related to this event.
     * @type {boolean}
     * @memberof TransactionUpdate
     */
    'fire_webhooks'?: boolean;
    /**
     * Title of the transaction if it has been split in more than one piece. Empty otherwise.
     * @type {string}
     * @memberof TransactionUpdate
     */
    'group_title'?: string | null;
    /**
     * 
     * @type {Array<TransactionSplitUpdate>}
     * @memberof TransactionUpdate
     */
    'transactions'?: Array<TransactionSplitUpdate>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * The new users email address.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * Boolean to indicate if the user is blocked.
     * @type {boolean}
     * @memberof User
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {UserBlockedCodeProperty}
     * @memberof User
     */
    'blocked_code'?: UserBlockedCodeProperty | null;
    /**
     * 
     * @type {UserRoleProperty}
     * @memberof User
     */
    'role'?: UserRoleProperty | null;
}
/**
 * 
 * @export
 * @interface UserArray
 */
export interface UserArray {
    /**
     * 
     * @type {Array<UserRead>}
     * @memberof UserArray
     */
    'data': Array<UserRead>;
    /**
     * 
     * @type {Meta}
     * @memberof UserArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof UserArray
     */
    'links': PageLink;
}
/**
 * If you say the user must be blocked, this will be the reason code.
 * @export
 * @enum {string}
 */

export const UserBlockedCodeProperty = {
    EmailChanged: 'email_changed',
    Null: 'null'
} as const;

export type UserBlockedCodeProperty = typeof UserBlockedCodeProperty[keyof typeof UserBlockedCodeProperty];


/**
 * 
 * @export
 * @interface UserRead
 */
export interface UserRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof UserRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof UserRead
     */
    'attributes': User;
    /**
     * 
     * @type {ObjectLink}
     * @memberof UserRead
     */
    'links': ObjectLink;
}
/**
 * Role for the user. Can be empty or omitted.
 * @export
 * @enum {string}
 */

export const UserRoleProperty = {
    Owner: 'owner',
    Demo: 'demo',
    Null: 'null'
} as const;

export type UserRoleProperty = typeof UserRoleProperty[keyof typeof UserRoleProperty];


/**
 * 
 * @export
 * @interface UserSingle
 */
export interface UserSingle {
    /**
     * 
     * @type {UserRead}
     * @memberof UserSingle
     */
    'data': UserRead;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'message'?: string;
    /**
     * 
     * @type {ValidationErrorErrors}
     * @memberof ValidationError
     */
    'errors'?: ValidationErrorErrors;
}
/**
 * 
 * @export
 * @interface ValidationErrorErrors
 */
export interface ValidationErrorErrors {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorErrors
     */
    'field1'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationErrorErrors
     */
    'field2'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updated_at'?: string;
    /**
     * Boolean to indicate if the webhook is active
     * @type {boolean}
     * @memberof Webhook
     */
    'active'?: boolean;
    /**
     * A title for the webhook for easy recognition.
     * @type {string}
     * @memberof Webhook
     */
    'title': string;
    /**
     * A 24-character secret for the webhook. It\'s generated by Firefly III when saving a new webhook. If you submit a new secret through the PUT endpoint it will generate a new secret for the selected webhook, a new secret bearing no relation to whatever you just submitted.
     * @type {string}
     * @memberof Webhook
     */
    'secret'?: string;
    /**
     * 
     * @type {WebhookTrigger}
     * @memberof Webhook
     */
    'trigger': WebhookTrigger;
    /**
     * 
     * @type {WebhookResponse}
     * @memberof Webhook
     */
    'response': WebhookResponse;
    /**
     * 
     * @type {WebhookDelivery}
     * @memberof Webhook
     */
    'delivery': WebhookDelivery;
    /**
     * The URL of the webhook. Has to start with `https`.
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WebhookArray
 */
export interface WebhookArray {
    /**
     * 
     * @type {Array<WebhookRead>}
     * @memberof WebhookArray
     */
    'data': Array<WebhookRead>;
    /**
     * 
     * @type {Meta}
     * @memberof WebhookArray
     */
    'meta': Meta;
    /**
     * 
     * @type {PageLink}
     * @memberof WebhookArray
     */
    'links': PageLink;
}
/**
 * 
 * @export
 * @interface WebhookAttempt
 */
export interface WebhookAttempt {
    /**
     * 
     * @type {string}
     * @memberof WebhookAttempt
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttempt
     */
    'updated_at'?: string;
    /**
     * The ID of the webhook message this attempt belongs to.
     * @type {string}
     * @memberof WebhookAttempt
     */
    'webhook_message_id'?: string;
    /**
     * The HTTP status code of the error, if any.
     * @type {number}
     * @memberof WebhookAttempt
     */
    'status_code'?: number | null;
    /**
     * Internal log for this attempt. May contain sensitive user data.
     * @type {string}
     * @memberof WebhookAttempt
     */
    'logs'?: string | null;
    /**
     * Webhook receiver response for this attempt, if any. May contain sensitive user data.
     * @type {string}
     * @memberof WebhookAttempt
     */
    'response'?: string | null;
}
/**
 * 
 * @export
 * @interface WebhookAttemptArray
 */
export interface WebhookAttemptArray {
    /**
     * 
     * @type {Array<WebhookAttemptRead>}
     * @memberof WebhookAttemptArray
     */
    'data': Array<WebhookAttemptRead>;
    /**
     * 
     * @type {Meta}
     * @memberof WebhookAttemptArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface WebhookAttemptRead
 */
export interface WebhookAttemptRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof WebhookAttemptRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookAttemptRead
     */
    'id': string;
    /**
     * 
     * @type {WebhookAttempt}
     * @memberof WebhookAttemptRead
     */
    'attributes': WebhookAttempt;
}
/**
 * 
 * @export
 * @interface WebhookAttemptSingle
 */
export interface WebhookAttemptSingle {
    /**
     * 
     * @type {WebhookAttemptRead}
     * @memberof WebhookAttemptSingle
     */
    'data': WebhookAttemptRead;
}
/**
 * Format of the delivered response.
 * @export
 * @enum {string}
 */

export const WebhookDelivery = {
    DeliveryJson: 'DELIVERY_JSON'
} as const;

export type WebhookDelivery = typeof WebhookDelivery[keyof typeof WebhookDelivery];


/**
 * 
 * @export
 * @interface WebhookMessage
 */
export interface WebhookMessage {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessage
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMessage
     */
    'updated_at'?: string;
    /**
     * If this message is sent yet.
     * @type {boolean}
     * @memberof WebhookMessage
     */
    'sent'?: boolean;
    /**
     * If this message has errored out.
     * @type {boolean}
     * @memberof WebhookMessage
     */
    'errored'?: boolean;
    /**
     * The ID of the webhook this message belongs to.
     * @type {string}
     * @memberof WebhookMessage
     */
    'webhook_id'?: string;
    /**
     * Long UUID string for identification of this webhook message.
     * @type {string}
     * @memberof WebhookMessage
     */
    'uuid'?: string;
    /**
     * The actual message that is sent or will be sent as JSON string.
     * @type {string}
     * @memberof WebhookMessage
     */
    'string'?: string | null;
}
/**
 * 
 * @export
 * @interface WebhookMessageArray
 */
export interface WebhookMessageArray {
    /**
     * 
     * @type {Array<WebhookMessageRead>}
     * @memberof WebhookMessageArray
     */
    'data': Array<WebhookMessageRead>;
    /**
     * 
     * @type {Meta}
     * @memberof WebhookMessageArray
     */
    'meta': Meta;
}
/**
 * 
 * @export
 * @interface WebhookMessageRead
 */
export interface WebhookMessageRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof WebhookMessageRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMessageRead
     */
    'id': string;
    /**
     * 
     * @type {WebhookMessage}
     * @memberof WebhookMessageRead
     */
    'attributes': WebhookMessage;
}
/**
 * 
 * @export
 * @interface WebhookMessageSingle
 */
export interface WebhookMessageSingle {
    /**
     * 
     * @type {WebhookMessageRead}
     * @memberof WebhookMessageSingle
     */
    'data': WebhookMessageRead;
}
/**
 * 
 * @export
 * @interface WebhookRead
 */
export interface WebhookRead {
    /**
     * Immutable value
     * @type {string}
     * @memberof WebhookRead
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookRead
     */
    'id': string;
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookRead
     */
    'attributes': Webhook;
    /**
     * 
     * @type {ObjectLink}
     * @memberof WebhookRead
     */
    'links': ObjectLink;
}
/**
 * Indicator for what Firefly III will deliver to the webhook URL.
 * @export
 * @enum {string}
 */

export const WebhookResponse = {
    Transactions: 'RESPONSE_TRANSACTIONS',
    Accounts: 'RESPONSE_ACCOUNTS',
    None: 'RESPONSE_NONE'
} as const;

export type WebhookResponse = typeof WebhookResponse[keyof typeof WebhookResponse];


/**
 * 
 * @export
 * @interface WebhookSingle
 */
export interface WebhookSingle {
    /**
     * 
     * @type {WebhookRead}
     * @memberof WebhookSingle
     */
    'data': WebhookRead;
}
/**
 * 
 * @export
 * @interface WebhookStore
 */
export interface WebhookStore {
    /**
     * Boolean to indicate if the webhook is active
     * @type {boolean}
     * @memberof WebhookStore
     */
    'active'?: boolean;
    /**
     * A title for the webhook for easy recognition.
     * @type {string}
     * @memberof WebhookStore
     */
    'title': string;
    /**
     * 
     * @type {WebhookTrigger}
     * @memberof WebhookStore
     */
    'trigger': WebhookTrigger;
    /**
     * 
     * @type {WebhookResponse}
     * @memberof WebhookStore
     */
    'response': WebhookResponse;
    /**
     * 
     * @type {WebhookDelivery}
     * @memberof WebhookStore
     */
    'delivery': WebhookDelivery;
    /**
     * The URL of the webhook. Has to start with `https`.
     * @type {string}
     * @memberof WebhookStore
     */
    'url': string;
}
/**
 * The trigger for the webhook.
 * @export
 * @enum {string}
 */

export const WebhookTrigger = {
    StoreTransaction: 'TRIGGER_STORE_TRANSACTION',
    UpdateTransaction: 'TRIGGER_UPDATE_TRANSACTION',
    DestroyTransaction: 'TRIGGER_DESTROY_TRANSACTION'
} as const;

export type WebhookTrigger = typeof WebhookTrigger[keyof typeof WebhookTrigger];


/**
 * 
 * @export
 * @interface WebhookUpdate
 */
export interface WebhookUpdate {
    /**
     * Boolean to indicate if the webhook is active
     * @type {boolean}
     * @memberof WebhookUpdate
     */
    'active'?: boolean;
    /**
     * A title for the webhook for easy recognition.
     * @type {string}
     * @memberof WebhookUpdate
     */
    'title'?: string;
    /**
     * A 24-character secret for the webhook. It\'s generated by Firefly III when saving a new webhook. If you submit a new secret through the PUT endpoint it will generate a new secret for the selected webhook, a new secret bearing no relation to whatever you just submitted.
     * @type {string}
     * @memberof WebhookUpdate
     */
    'secret'?: string;
    /**
     * 
     * @type {WebhookTrigger}
     * @memberof WebhookUpdate
     */
    'trigger'?: WebhookTrigger;
    /**
     * 
     * @type {WebhookResponse}
     * @memberof WebhookUpdate
     */
    'response'?: WebhookResponse;
    /**
     * 
     * @type {WebhookDelivery}
     * @memberof WebhookUpdate
     */
    'delivery'?: WebhookDelivery;
    /**
     * The URL of the webhook. Has to start with `https`.
     * @type {string}
     * @memberof WebhookUpdate
     */
    'url'?: string;
}

/**
 * AboutApi - axios parameter creator
 * @export
 */
export const AboutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns general system information and versions of the (supporting) software. 
         * @summary System information end point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users. 
         * @summary Cron job endpoint
         * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
         * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day. 
         * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCron: async (cliToken: string, date?: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cliToken' is not null or undefined
            assertParamExists('getCron', 'cliToken', cliToken)
            const localVarPath = `/api/v1/cron/{cliToken}`
                .replace(`{${"cliToken"}}`, encodeURIComponent(String(cliToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the currently authenticated user. 
         * @summary Currently authenticated user endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/about/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AboutApi - functional programming interface
 * @export
 */
export const AboutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AboutApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns general system information and versions of the (supporting) software. 
         * @summary System information end point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users. 
         * @summary Cron job endpoint
         * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
         * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day. 
         * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCron(cliToken: string, date?: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCron(cliToken, date, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the currently authenticated user. 
         * @summary Currently authenticated user endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AboutApi - factory interface
 * @export
 */
export const AboutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AboutApiFp(configuration)
    return {
        /**
         * Returns general system information and versions of the (supporting) software. 
         * @summary System information end point.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout(options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.getAbout(options).then((request) => request(axios, basePath));
        },
        /**
         * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users. 
         * @summary Cron job endpoint
         * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
         * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day. 
         * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCron(cliToken: string, date?: string, force?: boolean, options?: any): AxiosPromise<CronResult> {
            return localVarFp.getCron(cliToken, date, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the currently authenticated user. 
         * @summary Currently authenticated user endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<UserSingle> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AboutApi - object-oriented interface
 * @export
 * @class AboutApi
 * @extends {BaseAPI}
 */
export class AboutApi extends BaseAPI {
    /**
     * Returns general system information and versions of the (supporting) software. 
     * @summary System information end point.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AboutApi
     */
    public getAbout(options?: AxiosRequestConfig) {
        return AboutApiFp(this.configuration).getAbout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Firefly III has one endpoint for its various cron related tasks. Send a GET to this endpoint to run the cron. The cron requires the CLI token to be present. The cron job will fire for all users. 
     * @summary Cron job endpoint
     * @param {string} cliToken The CLI token of any user in Firefly III, required to run the cron job.
     * @param {string} [date] A date formatted YYYY-MM-DD. This can be used to make the cron job pretend it\&#39;s running on another day. 
     * @param {boolean} [force] Forces the cron job to fire, regardless of whether it has fired before. This may result in double transactions or weird budgets, so be careful. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AboutApi
     */
    public getCron(cliToken: string, date?: string, force?: boolean, options?: AxiosRequestConfig) {
        return AboutApiFp(this.configuration).getCron(cliToken, date, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the currently authenticated user. 
     * @summary Currently authenticated user endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AboutApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return AboutApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccount', 'id', id)
            const localVarPath = `/api/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single account by its ID. 
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, date?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/api/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user. 
         * @summary List all accounts.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount: async (page?: number, date?: string, type?: AccountTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByAccount: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByAccount', 'id', id)
            const localVarPath = `/api/v1/accounts/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account. 
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByAccount: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listPiggyBankByAccount', 'id', id)
            const localVarPath = `/api/v1/accounts/{id}/piggy_banks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account. 
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByAccount: async (id: string, page?: number, limit?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByAccount', 'id', id)
            const localVarPath = `/api/v1/accounts/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAccount: async (accountStore: AccountStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountStore' is not null or undefined
            assertParamExists('storeAccount', 'accountStore', accountStore)
            const localVarPath = `/api/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: string, accountUpdate: AccountUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'accountUpdate' is not null or undefined
            assertParamExists('updateAccount', 'accountUpdate', accountUpdate)
            const localVarPath = `/api/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single account by its ID. 
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, date?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user. 
         * @summary List all accounts.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccount(page?: number, date?: string, type?: AccountTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccount(page, date, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByAccount(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByAccount(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account. 
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPiggyBankByAccount(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPiggyBankByAccount(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account. 
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByAccount(id: string, page?: number, limit?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByAccount(id, page, limit, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeAccount(accountStore: AccountStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeAccount(accountStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: string, accountUpdate: AccountUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, accountUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
         * @summary Permanently delete account.
         * @param {string} id The ID of the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single account by its ID. 
         * @summary Get single account.
         * @param {string} id The ID of the account.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, date?: string, options?: any): AxiosPromise<AccountSingle> {
            return localVarFp.getAccount(id, date, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the accounts owned by the authenticated user. 
         * @summary List all accounts.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccount(page?: number, date?: string, type?: AccountTypeFilter, options?: any): AxiosPromise<AccountArray> {
            return localVarFp.listAccount(page, date, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByAccount(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByAccount(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the account. 
         * @summary List all piggy banks related to the account.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByAccount(id: string, page?: number, options?: any): AxiosPromise<PiggyBankArray> {
            return localVarFp.listPiggyBankByAccount(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the transactions connected to the account. 
         * @summary List all transactions related to the account.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByAccount(id: string, page?: number, limit?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByAccount(id, page, limit, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create new account.
         * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAccount(accountStore: AccountStore, options?: any): AxiosPromise<AccountSingle> {
            return localVarFp.storeAccount(accountStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
         * @summary Update existing account.
         * @param {string} id The ID of the account.
         * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: string, accountUpdate: AccountUpdate, options?: any): AxiosPromise<AccountSingle> {
            return localVarFp.updateAccount(id, accountUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. 
     * @summary Permanently delete account.
     * @param {string} id The ID of the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single account by its ID. 
     * @summary Get single account.
     * @param {string} id The ID of the account.
     * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(id: string, date?: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(id, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the accounts owned by the authenticated user. 
     * @summary List all accounts.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
     * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccount(page?: number, date?: string, type?: AccountTypeFilter, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccount(page, date, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the account.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAttachmentByAccount(id: string, page?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAttachmentByAccount(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the piggy banks connected to the account. 
     * @summary List all piggy banks related to the account.
     * @param {string} id The ID of the account.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listPiggyBankByAccount(id: string, page?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listPiggyBankByAccount(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the transactions connected to the account. 
     * @summary List all transactions related to the account.
     * @param {string} id The ID of the account.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {number} [limit] Limits the number of results on one page.
     * @param {string} [start] A date formatted YYYY-MM-DD. 
     * @param {string} [end] A date formatted YYYY-MM-DD. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listTransactionByAccount(id: string, page?: number, limit?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listTransactionByAccount(id, page, limit, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
     * @summary Create new account.
     * @param {AccountStore} accountStore JSON array with the necessary account information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public storeAccount(accountStore: AccountStore, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).storeAccount(accountStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. 
     * @summary Update existing account.
     * @param {string} id The ID of the account.
     * @param {AccountUpdate} accountUpdate JSON array or formdata with updated account information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(id: string, accountUpdate: AccountUpdate, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(id, accountUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
export const AttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * With this endpoint you delete an attachment, including any stored file data. 
         * @summary Delete an attachment.
         * @param {string} id The ID of the single.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAttachment', 'id', id)
            const localVarPath = `/api/v1/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\". 
         * @summary Download a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadAttachment', 'id', id)
            const localVarPath = `/api/v1/attachments/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below). 
         * @summary Get a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAttachment', 'id', id)
            const localVarPath = `/api/v1/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists all attachments. 
         * @summary List all attachments.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachment: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object. 
         * @summary Store a new attachment.
         * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAttachment: async (attachmentStore: AttachmentStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentStore' is not null or undefined
            assertParamExists('storeAttachment', 'attachmentStore', attachmentStore)
            const localVarPath = `/api/v1/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachmentStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below. 
         * @summary Update existing attachment.
         * @param {string} id The ID of the attachment.
         * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment: async (id: string, attachmentUpdate: AttachmentUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAttachment', 'id', id)
            // verify required parameter 'attachmentUpdate' is not null or undefined
            assertParamExists('updateAttachment', 'attachmentUpdate', attachmentUpdate)
            const localVarPath = `/api/v1/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachmentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data. 
         * @summary Upload an attachment.
         * @param {string} id The ID of the attachment.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: async (id: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadAttachment', 'id', id)
            const localVarPath = `/api/v1/attachments/{id}/upload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * With this endpoint you delete an attachment, including any stored file data. 
         * @summary Delete an attachment.
         * @param {string} id The ID of the single.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\". 
         * @summary Download a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAttachment(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAttachment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below). 
         * @summary Get a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists all attachments. 
         * @summary List all attachments.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachment(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachment(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object. 
         * @summary Store a new attachment.
         * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeAttachment(attachmentStore: AttachmentStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeAttachment(attachmentStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below. 
         * @summary Update existing attachment.
         * @param {string} id The ID of the attachment.
         * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttachment(id: string, attachmentUpdate: AttachmentUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttachment(id, attachmentUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data. 
         * @summary Upload an attachment.
         * @param {string} id The ID of the attachment.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAttachment(id: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAttachment(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttachmentsApiFp(configuration)
    return {
        /**
         * With this endpoint you delete an attachment, including any stored file data. 
         * @summary Delete an attachment.
         * @param {string} id The ID of the single.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\". 
         * @summary Download a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below). 
         * @summary Get a single attachment.
         * @param {string} id The ID of the attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, options?: any): AxiosPromise<AttachmentSingle> {
            return localVarFp.getAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists all attachments. 
         * @summary List all attachments.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachment(page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachment(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object. 
         * @summary Store a new attachment.
         * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAttachment(attachmentStore: AttachmentStore, options?: any): AxiosPromise<AttachmentSingle> {
            return localVarFp.storeAttachment(attachmentStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below. 
         * @summary Update existing attachment.
         * @param {string} id The ID of the attachment.
         * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment(id: string, attachmentUpdate: AttachmentUpdate, options?: any): AxiosPromise<AttachmentSingle> {
            return localVarFp.updateAttachment(id, attachmentUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data. 
         * @summary Upload an attachment.
         * @param {string} id The ID of the attachment.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(id: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadAttachment(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     * With this endpoint you delete an attachment, including any stored file data. 
     * @summary Delete an attachment.
     * @param {string} id The ID of the single.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public deleteAttachment(id: string, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).deleteAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type \"application/octet-stream\" and content disposition \"attachment; filename=example.pdf\". 
     * @summary Download a single attachment.
     * @param {string} id The ID of the attachment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public downloadAttachment(id: string, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).downloadAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below). 
     * @summary Get a single attachment.
     * @param {string} id The ID of the attachment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public getAttachment(id: string, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).getAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists all attachments. 
     * @summary List all attachments.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public listAttachment(page?: number, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).listAttachment(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object. 
     * @summary Store a new attachment.
     * @param {AttachmentStore} attachmentStore JSON array or key&#x3D;value pairs with the necessary attachment information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public storeAttachment(attachmentStore: AttachmentStore, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).storeAttachment(attachmentStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below. 
     * @summary Update existing attachment.
     * @param {string} id The ID of the attachment.
     * @param {AttachmentUpdate} attachmentUpdate JSON array with updated attachment information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public updateAttachment(id: string, attachmentUpdate: AttachmentUpdate, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).updateAttachment(id, attachmentUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data. 
     * @summary Upload an attachment.
     * @param {string} id The ID of the attachment.
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public uploadAttachment(id: string, body?: any, options?: AxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).uploadAttachment(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutocompleteApi - axios parameter creator
 * @export
 */
export const AutocompleteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all accounts of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query for accounts.
         * @param {number} [limit] The number of items returned.
         * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) used in the autocomplete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAC: async (query?: string, limit?: number, date?: string, type?: AccountTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all bills of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query for bills.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillsAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all budgets of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetsAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all categories of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all currencies of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesCodeAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/currencies-with-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all object groups of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroupsAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/object-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/piggy-banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array complemented with balance information.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesBalanceAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/piggy-banks-with-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all rule groups of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroupsAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/rule-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all rules of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all tags of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all transaction types returned in a basic auto-complete array. English only.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTypesAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/transaction-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsIDAC: async (query?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/autocomplete/transactions-with-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutocompleteApi - functional programming interface
 * @export
 */
export const AutocompleteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutocompleteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns all accounts of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query for accounts.
         * @param {number} [limit] The number of items returned.
         * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) used in the autocomplete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsAC(query?: string, limit?: number, date?: string, type?: AccountTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsAC(query, limit, date, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all bills of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query for bills.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBillsAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteBill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBillsAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all budgets of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetsAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteBudget>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetsAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all categories of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all currencies of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrenciesAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrenciesAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrenciesCodeAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteCurrencyCode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrenciesCodeAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all object groups of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectGroupsAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteObjectGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectGroupsAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPiggiesAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompletePiggy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPiggiesAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array complemented with balance information.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPiggiesBalanceAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompletePiggyBalance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPiggiesBalanceAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecurringAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteRecurrence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecurringAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all rule groups of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleGroupsAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteRuleGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleGroupsAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all rules of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRulesAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRulesAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all tags of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all transaction types returned in a basic auto-complete array. English only.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionTypesAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteTransactionType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionTypesAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsIDAC(query?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutocompleteTransactionID>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsIDAC(query, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutocompleteApi - factory interface
 * @export
 */
export const AutocompleteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutocompleteApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns all accounts of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query for accounts.
         * @param {number} [limit] The number of items returned.
         * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) used in the autocomplete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAC(query?: string, limit?: number, date?: string, type?: AccountTypeFilter, options?: any): AxiosPromise<Array<AutocompleteAccount>> {
            return localVarFp.getAccountsAC(query, limit, date, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all bills of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query for bills.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillsAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteBill>> {
            return localVarFp.getBillsAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all budgets of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetsAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteBudget>> {
            return localVarFp.getBudgetsAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all categories of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteCategory>> {
            return localVarFp.getCategoriesAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all currencies of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteCurrency>> {
            return localVarFp.getCurrenciesAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrenciesCodeAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteCurrencyCode>> {
            return localVarFp.getCurrenciesCodeAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all object groups of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroupsAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteObjectGroup>> {
            return localVarFp.getObjectGroupsAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompletePiggy>> {
            return localVarFp.getPiggiesAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all piggy banks of the user returned in a basic auto-complete array complemented with balance information.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggiesBalanceAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompletePiggyBalance>> {
            return localVarFp.getPiggiesBalanceAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteRecurrence>> {
            return localVarFp.getRecurringAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all rule groups of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroupsAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteRuleGroup>> {
            return localVarFp.getRuleGroupsAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all rules of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteRule>> {
            return localVarFp.getRulesAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all tags of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteTag>> {
            return localVarFp.getTagAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all transaction types returned in a basic auto-complete array. English only.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTypesAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteTransactionType>> {
            return localVarFp.getTransactionTypesAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteTransaction>> {
            return localVarFp.getTransactionsAC(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
         * @param {string} [query] The autocomplete search query.
         * @param {number} [limit] The number of items returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsIDAC(query?: string, limit?: number, options?: any): AxiosPromise<Array<AutocompleteTransactionID>> {
            return localVarFp.getTransactionsIDAC(query, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutocompleteApi - object-oriented interface
 * @export
 * @class AutocompleteApi
 * @extends {BaseAPI}
 */
export class AutocompleteApi extends BaseAPI {
    /**
     * 
     * @summary Returns all accounts of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query for accounts.
     * @param {number} [limit] The number of items returned.
     * @param {string} [date] If the account is an asset account or a liability, the autocomplete will also return the balance of the account on this date.
     * @param {AccountTypeFilter} [type] Optional filter on the account type(s) used in the autocomplete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getAccountsAC(query?: string, limit?: number, date?: string, type?: AccountTypeFilter, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getAccountsAC(query, limit, date, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all bills of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query for bills.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getBillsAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getBillsAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all budgets of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getBudgetsAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getBudgetsAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all categories of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getCategoriesAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getCategoriesAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all currencies of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getCurrenciesAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getCurrenciesAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all currencies of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getCurrenciesCodeAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getCurrenciesCodeAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all object groups of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getObjectGroupsAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getObjectGroupsAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all piggy banks of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getPiggiesAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getPiggiesAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all piggy banks of the user returned in a basic auto-complete array complemented with balance information.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getPiggiesBalanceAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getPiggiesBalanceAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all recurring transactions of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getRecurringAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getRecurringAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all rule groups of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getRuleGroupsAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getRuleGroupsAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all rules of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getRulesAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getRulesAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all tags of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getTagAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getTagAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all transaction types returned in a basic auto-complete array. English only.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getTransactionTypesAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getTransactionTypesAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all transaction descriptions of the user returned in a basic auto-complete array.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getTransactionsAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getTransactionsAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all transactions, complemented with their ID, of the user returned in a basic auto-complete array. This endpoint is DEPRECATED and I suggest you DO NOT use it.
     * @param {string} [query] The autocomplete search query.
     * @param {number} [limit] The number of items returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public getTransactionsIDAC(query?: string, limit?: number, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).getTransactionsIDAC(query, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AvailableBudgetsApi - axios parameter creator
 * @export
 */
export const AvailableBudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an available budget. Not much more to say.
         * @summary Delete an available budget.
         * @param {string} id The ID of the available budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAvailableBudget: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAvailableBudget', 'id', id)
            const localVarPath = `/api/v1/available_budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single available budget, by ID.
         * @summary Get a single available budget.
         * @param {string} id The ID of the available budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBudget: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAvailableBudget', 'id', id)
            const localVarPath = `/api/v1/available_budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set. 
         * @summary List all available budget amounts.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudget: async (page?: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/available_budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new available budget for a specified period. The data required can be submitted as a JSON body or as a list of parameters. 
         * @summary Store a new available budget
         * @param {AvailableBudgetStore} availableBudgetStore JSON array or key&#x3D;value pairs with the necessary available budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAvailableBudget: async (availableBudgetStore: AvailableBudgetStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'availableBudgetStore' is not null or undefined
            assertParamExists('storeAvailableBudget', 'availableBudgetStore', availableBudgetStore)
            const localVarPath = `/api/v1/available_budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableBudgetStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing available budget.
         * @summary Update existing available budget, to change for example the date range of the amount or the amount itself.
         * @param {string} id The ID of the object.X
         * @param {AvailableBudgetUpdate} availableBudgetUpdate JSON array or form value with updated available budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvailableBudget: async (id: string, availableBudgetUpdate: AvailableBudgetUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAvailableBudget', 'id', id)
            // verify required parameter 'availableBudgetUpdate' is not null or undefined
            assertParamExists('updateAvailableBudget', 'availableBudgetUpdate', availableBudgetUpdate)
            const localVarPath = `/api/v1/available_budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availableBudgetUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailableBudgetsApi - functional programming interface
 * @export
 */
export const AvailableBudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvailableBudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an available budget. Not much more to say.
         * @summary Delete an available budget.
         * @param {string} id The ID of the available budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAvailableBudget(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAvailableBudget(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single available budget, by ID.
         * @summary Get a single available budget.
         * @param {string} id The ID of the available budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableBudget(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableBudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableBudget(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set. 
         * @summary List all available budget amounts.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableBudget(page?: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableBudgetArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableBudget(page, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new available budget for a specified period. The data required can be submitted as a JSON body or as a list of parameters. 
         * @summary Store a new available budget
         * @param {AvailableBudgetStore} availableBudgetStore JSON array or key&#x3D;value pairs with the necessary available budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeAvailableBudget(availableBudgetStore: AvailableBudgetStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableBudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeAvailableBudget(availableBudgetStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing available budget.
         * @summary Update existing available budget, to change for example the date range of the amount or the amount itself.
         * @param {string} id The ID of the object.X
         * @param {AvailableBudgetUpdate} availableBudgetUpdate JSON array or form value with updated available budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAvailableBudget(id: string, availableBudgetUpdate: AvailableBudgetUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableBudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvailableBudget(id, availableBudgetUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AvailableBudgetsApi - factory interface
 * @export
 */
export const AvailableBudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvailableBudgetsApiFp(configuration)
    return {
        /**
         * Delete an available budget. Not much more to say.
         * @summary Delete an available budget.
         * @param {string} id The ID of the available budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAvailableBudget(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAvailableBudget(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single available budget, by ID.
         * @summary Get a single available budget.
         * @param {string} id The ID of the available budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBudget(id: string, options?: any): AxiosPromise<AvailableBudgetSingle> {
            return localVarFp.getAvailableBudget(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set. 
         * @summary List all available budget amounts.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudget(page?: number, start?: string, end?: string, options?: any): AxiosPromise<AvailableBudgetArray> {
            return localVarFp.listAvailableBudget(page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new available budget for a specified period. The data required can be submitted as a JSON body or as a list of parameters. 
         * @summary Store a new available budget
         * @param {AvailableBudgetStore} availableBudgetStore JSON array or key&#x3D;value pairs with the necessary available budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAvailableBudget(availableBudgetStore: AvailableBudgetStore, options?: any): AxiosPromise<AvailableBudgetSingle> {
            return localVarFp.storeAvailableBudget(availableBudgetStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing available budget.
         * @summary Update existing available budget, to change for example the date range of the amount or the amount itself.
         * @param {string} id The ID of the object.X
         * @param {AvailableBudgetUpdate} availableBudgetUpdate JSON array or form value with updated available budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvailableBudget(id: string, availableBudgetUpdate: AvailableBudgetUpdate, options?: any): AxiosPromise<AvailableBudgetSingle> {
            return localVarFp.updateAvailableBudget(id, availableBudgetUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvailableBudgetsApi - object-oriented interface
 * @export
 * @class AvailableBudgetsApi
 * @extends {BaseAPI}
 */
export class AvailableBudgetsApi extends BaseAPI {
    /**
     * Delete an available budget. Not much more to say.
     * @summary Delete an available budget.
     * @param {string} id The ID of the available budget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableBudgetsApi
     */
    public deleteAvailableBudget(id: string, options?: AxiosRequestConfig) {
        return AvailableBudgetsApiFp(this.configuration).deleteAvailableBudget(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single available budget, by ID.
     * @summary Get a single available budget.
     * @param {string} id The ID of the available budget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableBudgetsApi
     */
    public getAvailableBudget(id: string, options?: AxiosRequestConfig) {
        return AvailableBudgetsApiFp(this.configuration).getAvailableBudget(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Firefly III allows users to set the amount that is available to be budgeted in so-called \"available budgets\". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set. 
     * @summary List all available budget amounts.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. 
     * @param {string} [end] A date formatted YYYY-MM-DD. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableBudgetsApi
     */
    public listAvailableBudget(page?: number, start?: string, end?: string, options?: AxiosRequestConfig) {
        return AvailableBudgetsApiFp(this.configuration).listAvailableBudget(page, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new available budget for a specified period. The data required can be submitted as a JSON body or as a list of parameters. 
     * @summary Store a new available budget
     * @param {AvailableBudgetStore} availableBudgetStore JSON array or key&#x3D;value pairs with the necessary available budget information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableBudgetsApi
     */
    public storeAvailableBudget(availableBudgetStore: AvailableBudgetStore, options?: AxiosRequestConfig) {
        return AvailableBudgetsApiFp(this.configuration).storeAvailableBudget(availableBudgetStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing available budget.
     * @summary Update existing available budget, to change for example the date range of the amount or the amount itself.
     * @param {string} id The ID of the object.X
     * @param {AvailableBudgetUpdate} availableBudgetUpdate JSON array or form value with updated available budget information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableBudgetsApi
     */
    public updateAvailableBudget(id: string, availableBudgetUpdate: AvailableBudgetUpdate, options?: AxiosRequestConfig) {
        return AvailableBudgetsApiFp(this.configuration).updateAvailableBudget(id, availableBudgetUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillsApi - axios parameter creator
 * @export
 */
export const BillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
         * @summary Delete a bill.
         * @param {string} id The ID of the bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBill: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBill', 'id', id)
            const localVarPath = `/api/v1/bills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single bill.
         * @summary Get a single bill.
         * @param {string} id The ID of the bill.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBill: async (id: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBill', 'id', id)
            const localVarPath = `/api/v1/bills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will list all attachments linked to the bill.
         * @summary List all attachments uploaded to the bill.
         * @param {string} id The ID of the bill.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBill: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByBill', 'id', id)
            const localVarPath = `/api/v1/bills/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will list all the user\'s bills.
         * @summary List all bills.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBill: async (page?: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will list all rules that have an action to set the bill to this bill.
         * @summary List all rules associated with the bill.
         * @param {string} id The ID of the bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByBill: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRuleByBill', 'id', id)
            const localVarPath = `/api/v1/bills/{id}/rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will list all transactions linked to this bill.
         * @summary List all transactions associated with the  bill.
         * @param {string} id The ID of the bill.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBill: async (id: string, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByBill', 'id', id)
            const localVarPath = `/api/v1/bills/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new bill
         * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBill: async (billStore: BillStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'billStore' is not null or undefined
            assertParamExists('storeBill', 'billStore', billStore)
            const localVarPath = `/api/v1/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing bill.
         * @summary Update existing bill.
         * @param {string} id The ID of the bill.
         * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBill: async (id: string, billUpdate: BillUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBill', 'id', id)
            // verify required parameter 'billUpdate' is not null or undefined
            assertParamExists('updateBill', 'billUpdate', billUpdate)
            const localVarPath = `/api/v1/bills/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillsApi - functional programming interface
 * @export
 */
export const BillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
         * @summary Delete a bill.
         * @param {string} id The ID of the bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBill(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBill(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single bill.
         * @summary Get a single bill.
         * @param {string} id The ID of the bill.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBill(id: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBill(id, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will list all attachments linked to the bill.
         * @summary List all attachments uploaded to the bill.
         * @param {string} id The ID of the bill.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByBill(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByBill(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will list all the user\'s bills.
         * @summary List all bills.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBill(page?: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBill(page, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will list all rules that have an action to set the bill to this bill.
         * @summary List all rules associated with the bill.
         * @param {string} id The ID of the bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleByBill(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleByBill(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will list all transactions linked to this bill.
         * @summary List all transactions associated with the  bill.
         * @param {string} id The ID of the bill.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByBill(id: string, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByBill(id, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new bill
         * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeBill(billStore: BillStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeBill(billStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing bill.
         * @summary Update existing bill.
         * @param {string} id The ID of the bill.
         * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBill(id: string, billUpdate: BillUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBill(id, billUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillsApi - factory interface
 * @export
 */
export const BillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillsApiFp(configuration)
    return {
        /**
         * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
         * @summary Delete a bill.
         * @param {string} id The ID of the bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBill(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBill(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single bill.
         * @summary Get a single bill.
         * @param {string} id The ID of the bill.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBill(id: string, start?: string, end?: string, options?: any): AxiosPromise<BillSingle> {
            return localVarFp.getBill(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all attachments linked to the bill.
         * @summary List all attachments uploaded to the bill.
         * @param {string} id The ID of the bill.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBill(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByBill(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all the user\'s bills.
         * @summary List all bills.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBill(page?: number, start?: string, end?: string, options?: any): AxiosPromise<BillArray> {
            return localVarFp.listBill(page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all rules that have an action to set the bill to this bill.
         * @summary List all rules associated with the bill.
         * @param {string} id The ID of the bill.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByBill(id: string, options?: any): AxiosPromise<RuleArray> {
            return localVarFp.listRuleByBill(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will list all transactions linked to this bill.
         * @summary List all transactions associated with the  bill.
         * @param {string} id The ID of the bill.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBill(id: string, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByBill(id, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new bill
         * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBill(billStore: BillStore, options?: any): AxiosPromise<BillSingle> {
            return localVarFp.storeBill(billStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing bill.
         * @summary Update existing bill.
         * @param {string} id The ID of the bill.
         * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBill(id: string, billUpdate: BillUpdate, options?: any): AxiosPromise<BillSingle> {
            return localVarFp.updateBill(id, billUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillsApi - object-oriented interface
 * @export
 * @class BillsApi
 * @extends {BaseAPI}
 */
export class BillsApi extends BaseAPI {
    /**
     * Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments.
     * @summary Delete a bill.
     * @param {string} id The ID of the bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public deleteBill(id: string, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).deleteBill(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single bill.
     * @summary Get a single bill.
     * @param {string} id The ID of the bill.
     * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
     * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public getBill(id: string, start?: string, end?: string, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).getBill(id, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will list all attachments linked to the bill.
     * @summary List all attachments uploaded to the bill.
     * @param {string} id The ID of the bill.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public listAttachmentByBill(id: string, page?: number, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).listAttachmentByBill(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will list all the user\'s bills.
     * @summary List all bills.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. 
     * @param {string} [end] A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public listBill(page?: number, start?: string, end?: string, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).listBill(page, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will list all rules that have an action to set the bill to this bill.
     * @summary List all rules associated with the bill.
     * @param {string} id The ID of the bill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public listRuleByBill(id: string, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).listRuleByBill(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will list all transactions linked to this bill.
     * @summary List all transactions associated with the  bill.
     * @param {string} id The ID of the bill.
     * @param {string} [start] A date formatted YYYY-MM-DD. 
     * @param {string} [end] A date formatted YYYY-MM-DD. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public listTransactionByBill(id: string, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).listTransactionByBill(id, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new bill
     * @param {BillStore} billStore JSON array or key&#x3D;value pairs with the necessary bill information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public storeBill(billStore: BillStore, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).storeBill(billStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing bill.
     * @summary Update existing bill.
     * @param {string} id The ID of the bill.
     * @param {BillUpdate} billUpdate JSON array or key&#x3D;value pairs with updated bill information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillsApi
     */
    public updateBill(id: string, billUpdate: BillUpdate, options?: AxiosRequestConfig) {
        return BillsApiFp(this.configuration).updateBill(id, billUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BudgetsApi - axios parameter creator
 * @export
 */
export const BudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit: async (id: string, limitId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('deleteBudgetLimit', 'limitId', limitId)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget: async (id: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit: async (id: string, limitId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('getBudgetLimit', 'limitId', limitId)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget: async (page?: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit: async (start: string, end: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('listBudgetLimit', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('listBudgetLimit', 'end', end)
            const localVarPath = `/api/v1/budget-limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget: async (id: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listBudgetLimitByBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget: async (id: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByBudget', 'id', id)
            const localVarPath = `/api/v1/budgets/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit: async (id: string, limitId: string, page?: number, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('listTransactionByBudgetLimit', 'limitId', limitId)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions without a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutBudget: async (limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/budgets/transactions-without-budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget: async (budgetStore: BudgetStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetStore' is not null or undefined
            assertParamExists('storeBudget', 'budgetStore', budgetStore)
            const localVarPath = `/api/v1/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit: async (id: string, budgetLimitStore: BudgetLimitStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storeBudgetLimit', 'id', id)
            // verify required parameter 'budgetLimitStore' is not null or undefined
            assertParamExists('storeBudgetLimit', 'budgetLimitStore', budgetLimitStore)
            const localVarPath = `/api/v1/budgets/{id}/limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetLimitStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget: async (id: string, budgetUpdate: BudgetUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBudget', 'id', id)
            // verify required parameter 'budgetUpdate' is not null or undefined
            assertParamExists('updateBudget', 'budgetUpdate', budgetUpdate)
            const localVarPath = `/api/v1/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit: async (id: string, limitId: string, budgetLimit: BudgetLimit, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBudgetLimit', 'id', id)
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('updateBudgetLimit', 'limitId', limitId)
            // verify required parameter 'budgetLimit' is not null or undefined
            assertParamExists('updateBudgetLimit', 'budgetLimit', budgetLimit)
            const localVarPath = `/api/v1/budgets/{id}/limits/{limitId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"limitId"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetLimit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudget(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudget(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudgetLimit(id: string, limitId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudgetLimit(id, limitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudget(id: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudget(id, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBudgetLimit(id: string, limitId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBudgetLimit(id, limitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByBudget(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByBudget(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudget(page?: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudget(page, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimit(start: string, end: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimit(start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimitByBudget(id: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimitByBudget(id, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByBudget(id: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByBudget(id, limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByBudgetLimit(id: string, limitId: string, page?: number, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByBudgetLimit(id, limitId, page, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions without a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionWithoutBudget(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionWithoutBudget(limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeBudget(budgetStore: BudgetStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeBudget(budgetStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeBudgetLimit(id: string, budgetLimitStore: BudgetLimitStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeBudgetLimit(id, budgetLimitStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudget(id: string, budgetUpdate: BudgetUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudget(id, budgetUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudgetLimit(id: string, limitId: string, budgetLimit: BudgetLimit, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudgetLimit(id, limitId, budgetLimit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetsApiFp(configuration)
    return {
        /**
         * Delete a budget. Transactions will not be deleted.
         * @summary Delete a budget.
         * @param {string} id The ID of the budget.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBudget(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a budget limit.
         * @summary Delete a budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetLimit(id: string, limitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBudgetLimit(id, limitId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary Get a single budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudget(id: string, start?: string, end?: string, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.getBudget(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetLimit(id: string, limitId: number, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.getBudgetLimit(id, limitId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments of a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByBudget(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByBudget(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
         * @summary List all budgets.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudget(page?: number, start?: string, end?: string, options?: any): AxiosPromise<BudgetArray> {
            return localVarFp.listBudget(page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for for this date range. 
         * @summary Get list of budget limits by date
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimit(start: string, end: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimit(start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
         * @summary Get all limits for a budget.
         * @param {string} id The ID of the requested budget.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByBudget(id: string, start?: string, end?: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimitByBudget(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions linked to a budget, possibly limited by start and end
         * @summary All transactions to a budget.
         * @param {string} id The ID of the budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudget(id: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByBudget(id, limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
         * @summary List all transactions by a budget limit ID.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByBudgetLimit(id: string, limitId: string, page?: number, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByBudgetLimit(id, limitId, page, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions without a budget, possibly limited by start and end
         * @summary All transactions without a budget.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutBudget(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionWithoutBudget(limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new budget
         * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudget(budgetStore: BudgetStore, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.storeBudget(budgetStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a new budget limit under this budget.
         * @summary Store new budget limit.
         * @param {string} id The ID of the budget.
         * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeBudgetLimit(id: string, budgetLimitStore: BudgetLimitStore, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.storeBudgetLimit(id, budgetLimitStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget. This endpoint cannot be used to set budget amount limits.
         * @summary Update existing budget.
         * @param {string} id The ID of the budget.
         * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget(id: string, budgetUpdate: BudgetUpdate, options?: any): AxiosPromise<BudgetSingle> {
            return localVarFp.updateBudget(id, budgetUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing budget limit.
         * @summary Update existing budget limit.
         * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
         * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
         * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetLimit(id: string, limitId: string, budgetLimit: BudgetLimit, options?: any): AxiosPromise<BudgetLimitSingle> {
            return localVarFp.updateBudgetLimit(id, limitId, budgetLimit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * Delete a budget. Transactions will not be deleted.
     * @summary Delete a budget.
     * @param {string} id The ID of the budget.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public deleteBudget(id: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).deleteBudget(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a budget limit.
     * @summary Delete a budget limit.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public deleteBudgetLimit(id: string, limitId: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).deleteBudgetLimit(id, limitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single budget. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary Get a single budget.
     * @param {string} id The ID of the requested budget.
     * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudget(id: string, start?: string, end?: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).getBudget(id, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single budget limit.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {number} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgetLimit(id: string, limitId: number, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).getBudgetLimit(id, limitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments of a budget.
     * @param {string} id The ID of the budget.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listAttachmentByBudget(id: string, page?: number, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listAttachmentByBudget(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the budgets the user has made. If the start date and end date are submitted as well, the \"spent\" array will be updated accordingly.
     * @summary List all budgets.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudget(page?: number, start?: string, end?: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listBudget(page, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all budget limits for for this date range. 
     * @summary Get list of budget limits by date
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudgetLimit(start: string, end: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listBudgetLimit(start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \"spent\" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
     * @summary Get all limits for a budget.
     * @param {string} id The ID of the requested budget.
     * @param {string} [start] A date formatted YYYY-MM-DD. 
     * @param {string} [end] A date formatted YYYY-MM-DD. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listBudgetLimitByBudget(id: string, start?: string, end?: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listBudgetLimitByBudget(id, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions linked to a budget, possibly limited by start and end
     * @summary All transactions to a budget.
     * @param {string} id The ID of the budget.
     * @param {number} [limit] Limits the number of results on one page.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. 
     * @param {string} [end] A date formatted YYYY-MM-DD. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionByBudget(id: string, limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listTransactionByBudget(id, limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
     * @summary List all transactions by a budget limit ID.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionByBudgetLimit(id: string, limitId: string, page?: number, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listTransactionByBudgetLimit(id, limitId, page, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions without a budget, possibly limited by start and end
     * @summary All transactions without a budget.
     * @param {number} [limit] Limits the number of results on one page.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. 
     * @param {string} [end] A date formatted YYYY-MM-DD. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listTransactionWithoutBudget(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listTransactionWithoutBudget(limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new budget
     * @param {BudgetStore} budgetStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public storeBudget(budgetStore: BudgetStore, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).storeBudget(budgetStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Store a new budget limit under this budget.
     * @summary Store new budget limit.
     * @param {string} id The ID of the budget.
     * @param {BudgetLimitStore} budgetLimitStore JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public storeBudgetLimit(id: string, budgetLimitStore: BudgetLimitStore, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).storeBudgetLimit(id, budgetLimitStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing budget. This endpoint cannot be used to set budget amount limits.
     * @summary Update existing budget.
     * @param {string} id The ID of the budget.
     * @param {BudgetUpdate} budgetUpdate JSON array with updated budget information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public updateBudget(id: string, budgetUpdate: BudgetUpdate, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).updateBudget(id, budgetUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing budget limit.
     * @summary Update existing budget limit.
     * @param {string} id The ID of the budget. The budget limit MUST be associated to the budget ID.
     * @param {string} limitId The ID of the budget limit. The budget limit MUST be associated to the budget ID.
     * @param {BudgetLimit} budgetLimit JSON array with updated budget limit information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public updateBudgetLimit(id: string, limitId: string, budgetLimit: BudgetLimit, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).updateBudgetLimit(id, limitId, budgetLimit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (id: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory: async (id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByCategory', 'id', id)
            const localVarPath = `/api/v1/categories/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions without a category, possibly limited by start and end
         * @summary All transactions without a category.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutCategory: async (limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/categories/transactions-without-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory: async (category: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('storeCategory', 'category', category)
            const localVarPath = `/api/v1/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, categoryUpdate: CategoryUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'categoryUpdate' is not null or undefined
            assertParamExists('updateCategory', 'categoryUpdate', categoryUpdate)
            const localVarPath = `/api/v1/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(id: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(id, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByCategory(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByCategory(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategory(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategory(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByCategory(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByCategory(id, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions without a category, possibly limited by start and end
         * @summary All transactions without a category.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionWithoutCategory(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionWithoutCategory(limit, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCategory(category: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, categoryUpdate: CategoryUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategorySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, categoryUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Delete a category. Transactions will not be removed.
         * @summary Delete a category.
         * @param {string} id The ID of the category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single category.
         * @summary Get a single category.
         * @param {string} id The ID of the category.
         * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(id: string, start?: string, end?: string, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.getCategory(id, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByCategory(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByCategory(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all categories.
         * @summary List all categories.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategory(page?: number, options?: any): AxiosPromise<CategoryArray> {
            return localVarFp.listCategory(page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions in a category, optionally limited to the date ranges specified.
         * @summary List all transactions in a category.
         * @param {string} id The ID of the category.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCategory(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByCategory(id, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions without a category, possibly limited by start and end
         * @summary All transactions without a category.
         * @param {number} [limit] Limits the number of results on one page.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. 
         * @param {string} [end] A date formatted YYYY-MM-DD. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionWithoutCategory(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionWithoutCategory(limit, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new category
         * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCategory(category: Category, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.storeCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing category.
         * @summary Update existing category.
         * @param {string} id The ID of the category.
         * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, categoryUpdate: CategoryUpdate, options?: any): AxiosPromise<CategorySingle> {
            return localVarFp.updateCategory(id, categoryUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Delete a category. Transactions will not be removed.
     * @summary Delete a category.
     * @param {string} id The ID of the category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategory(id: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).deleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single category.
     * @summary Get a single category.
     * @param {string} id The ID of the category.
     * @param {string} [start] A date formatted YYYY-MM-DD, to show spent and earned info. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to show spent and earned info. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategory(id: string, start?: string, end?: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategory(id, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the category.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listAttachmentByCategory(id: string, page?: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listAttachmentByCategory(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all categories.
     * @summary List all categories.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listCategory(page?: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listCategory(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions in a category, optionally limited to the date ranges specified.
     * @summary List all transactions in a category.
     * @param {string} id The ID of the category.
     * @param {number} [page] Page number. The default pagination is per 50.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the result list. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the result list. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listTransactionByCategory(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listTransactionByCategory(id, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions without a category, possibly limited by start and end
     * @summary All transactions without a category.
     * @param {number} [limit] Limits the number of results on one page.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. 
     * @param {string} [end] A date formatted YYYY-MM-DD. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listTransactionWithoutCategory(limit?: number, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listTransactionWithoutCategory(limit, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new category. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new category
     * @param {Category} category JSON array or key&#x3D;value pairs with the necessary category information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public storeCategory(category: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).storeCategory(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing category.
     * @summary Update existing category.
     * @param {string} id The ID of the category.
     * @param {CategoryUpdate} categoryUpdate JSON array with updated category information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(id: string, categoryUpdate: CategoryUpdate, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).updateCategory(id, categoryUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChartsApi - axios parameter creator
 * @export
 */
export const ChartsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the data required to generate a chart with basic asset account balance information. 
         * @summary Dashboard chart with asset account balance information.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartAccountOverview: async (start: string, end: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getChartAccountOverview', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getChartAccountOverview', 'end', end)
            const localVarPath = `/api/v1/chart/account/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartsApi - functional programming interface
 * @export
 */
export const ChartsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChartsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns the data required to generate a chart with basic asset account balance information. 
         * @summary Dashboard chart with asset account balance information.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChartAccountOverview(start: string, end: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChartDataSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChartAccountOverview(start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChartsApi - factory interface
 * @export
 */
export const ChartsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChartsApiFp(configuration)
    return {
        /**
         * This endpoint returns the data required to generate a chart with basic asset account balance information. 
         * @summary Dashboard chart with asset account balance information.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartAccountOverview(start: string, end: string, options?: any): AxiosPromise<Array<ChartDataSet>> {
            return localVarFp.getChartAccountOverview(start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChartsApi - object-oriented interface
 * @export
 * @class ChartsApi
 * @extends {BaseAPI}
 */
export class ChartsApi extends BaseAPI {
    /**
     * This endpoint returns the data required to generate a chart with basic asset account balance information. 
     * @summary Dashboard chart with asset account balance information.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public getChartAccountOverview(start: string, end: string, options?: AxiosRequestConfig) {
        return ChartsApiFp(this.configuration).getChartAccountOverview(start, end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all editable and not-editable configuration values for this Firefly III installation
         * @summary Get Firefly III system configuration values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns one configuration variable for this Firefly III installation
         * @summary Get a single Firefly III system configuration value
         * @param {ConfigValueFilter} name The name of the configuration value you want to know.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleConfiguration: async (name: ConfigValueFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getSingleConfiguration', 'name', name)
            const localVarPath = `/api/v1/configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
         * @summary Update configuration value
         * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
         * @param {PolymorphicProperty} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfiguration: async (name: ConfigValueUpdateFilter, value: PolymorphicProperty, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('setConfiguration', 'name', name)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('setConfiguration', 'value', value)
            const localVarPath = `/api/v1/configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


            if (value !== undefined) { 
                localVarFormParams.set('value', value as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all editable and not-editable configuration values for this Firefly III installation
         * @summary Get Firefly III system configuration values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FireflyConfiguration>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns one configuration variable for this Firefly III installation
         * @summary Get a single Firefly III system configuration value
         * @param {ConfigValueFilter} name The name of the configuration value you want to know.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleConfiguration(name: ConfigValueFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleConfiguration(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
         * @summary Update configuration value
         * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
         * @param {PolymorphicProperty} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfiguration(name: ConfigValueUpdateFilter, value: PolymorphicProperty, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfiguration(name, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationApiFp(configuration)
    return {
        /**
         * Returns all editable and not-editable configuration values for this Firefly III installation
         * @summary Get Firefly III system configuration values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(options?: any): AxiosPromise<Array<FireflyConfiguration>> {
            return localVarFp.getConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one configuration variable for this Firefly III installation
         * @summary Get a single Firefly III system configuration value
         * @param {ConfigValueFilter} name The name of the configuration value you want to know.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleConfiguration(name: ConfigValueFilter, options?: any): AxiosPromise<ConfigurationSingle> {
            return localVarFp.getSingleConfiguration(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
         * @summary Update configuration value
         * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
         * @param {PolymorphicProperty} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfiguration(name: ConfigValueUpdateFilter, value: PolymorphicProperty, options?: any): AxiosPromise<ConfigurationSingle> {
            return localVarFp.setConfiguration(name, value, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * Returns all editable and not-editable configuration values for this Firefly III installation
     * @summary Get Firefly III system configuration values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getConfiguration(options?: AxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns one configuration variable for this Firefly III installation
     * @summary Get a single Firefly III system configuration value
     * @param {ConfigValueFilter} name The name of the configuration value you want to know.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getSingleConfiguration(name: ConfigValueFilter, options?: AxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getSingleConfiguration(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a single configuration value. Not all configuration values can be updated so the list of accepted configuration variables is small.
     * @summary Update configuration value
     * @param {ConfigValueUpdateFilter} name The name of the configuration value you want to update.
     * @param {PolymorphicProperty} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public setConfiguration(name: ConfigValueUpdateFilter, value: PolymorphicProperty, options?: AxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).setConfiguration(name, value, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultCurrency: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('defaultCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/default`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('deleteCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {number} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCurrency: async (code: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('disableCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/disable`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCurrency: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('enableCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/enable`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s default currency.
         * @summary Get the user\'s default currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultCurrency: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/currencies/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountByCurrency: async (code: string, page?: number, date?: string, type?: AccountTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listAccountByCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/accounts`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudgetByCurrency: async (code: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listAvailableBudgetByCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/available_budgets`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByCurrency: async (code: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listBillByCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/bills`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByCurrency: async (code: string, page?: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listBudgetLimitByCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/budget_limits`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrenceByCurrency: async (code: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listRecurrenceByCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/recurrences`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination per 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByCurrency: async (code: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listRuleByCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/rules`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCurrency: async (code: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('listTransactionByCurrency', 'code', code)
            const localVarPath = `/api/v1/currencies/{code}/transactions`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrency: async (currencyStore: CurrencyStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyStore' is not null or undefined
            assertParamExists('storeCurrency', 'currencyStore', currencyStore)
            const localVarPath = `/api/v1/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency: async (code: string, currencyUpdate: CurrencyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('updateCurrency', 'code', code)
            // verify required parameter 'currencyUpdate' is not null or undefined
            assertParamExists('updateCurrency', 'currencyUpdate', currencyUpdate)
            const localVarPath = `/api/v1/currencies/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultCurrency(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultCurrency(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCurrency(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCurrency(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {number} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableCurrency(code: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableCurrency(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableCurrency(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableCurrency(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrency(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrency(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user\'s default currency.
         * @summary Get the user\'s default currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultCurrency(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultCurrency(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountByCurrency(code: string, page?: number, date?: string, type?: AccountTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountByCurrency(code, page, date, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAvailableBudgetByCurrency(code: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableBudgetArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailableBudgetByCurrency(code, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBillByCurrency(code: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBillByCurrency(code, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBudgetLimitByCurrency(code: string, page?: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetLimitArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBudgetLimitByCurrency(code, page, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCurrency(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencyArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCurrency(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecurrenceByCurrency(code: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurrenceArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecurrenceByCurrency(code, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination per 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleByCurrency(code: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleByCurrency(code, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByCurrency(code: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByCurrency(code, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCurrency(currencyStore: CurrencyStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCurrency(currencyStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrency(code: string, currencyUpdate: CurrencyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrencySingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrency(code, currencyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrenciesApiFp(configuration)
    return {
        /**
         * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
         * @summary Make currency default currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultCurrency(code: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.defaultCurrency(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a currency.
         * @summary Delete a currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency(code: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCurrency(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a currency.
         * @summary Disable a currency.
         * @param {number} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableCurrency(code: number, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.disableCurrency(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a single currency.
         * @summary Enable a single currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableCurrency(code: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.enableCurrency(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single currency.
         * @summary Get a single currency.
         * @param {string} code The currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrency(code: string, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.getCurrency(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s default currency.
         * @summary Get the user\'s default currency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultCurrency(options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.getDefaultCurrency(options).then((request) => request(axios, basePath));
        },
        /**
         * List all accounts with this currency.
         * @summary List all accounts with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
         * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountByCurrency(code: string, page?: number, date?: string, type?: AccountTypeFilter, options?: any): AxiosPromise<AccountArray> {
            return localVarFp.listAccountByCurrency(code, page, date, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available budgets with this currency.
         * @summary List all available budgets with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAvailableBudgetByCurrency(code: string, page?: number, options?: any): AxiosPromise<AvailableBudgetArray> {
            return localVarFp.listAvailableBudgetByCurrency(code, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all bills with this currency.
         * @summary List all bills with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByCurrency(code: string, page?: number, options?: any): AxiosPromise<BillArray> {
            return localVarFp.listBillByCurrency(code, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all budget limits with this currency
         * @summary List all budget limits with this currency
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] Start date for the budget limit list.
         * @param {string} [end] End date for the budget limit list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBudgetLimitByCurrency(code: string, page?: number, start?: string, end?: string, options?: any): AxiosPromise<BudgetLimitArray> {
            return localVarFp.listBudgetLimitByCurrency(code, page, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * List all currencies.
         * @summary List all currencies.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCurrency(page?: number, options?: any): AxiosPromise<CurrencyArray> {
            return localVarFp.listCurrency(page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all recurring transactions with this currency.
         * @summary List all recurring transactions with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrenceByCurrency(code: string, page?: number, options?: any): AxiosPromise<RecurrenceArray> {
            return localVarFp.listRecurrenceByCurrency(code, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rules with this currency.
         * @summary List all rules with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination per 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByCurrency(code: string, page?: number, options?: any): AxiosPromise<RuleArray> {
            return localVarFp.listRuleByCurrency(code, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions with this currency.
         * @summary List all transactions with this currency.
         * @param {string} code The currency code.
         * @param {number} [page] Page number. The default pagination is per 50.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByCurrency(code: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByCurrency(code, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new currency
         * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCurrency(currencyStore: CurrencyStore, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.storeCurrency(currencyStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing currency.
         * @summary Update existing currency.
         * @param {string} code The currency code.
         * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(code: string, currencyUpdate: CurrencyUpdate, options?: any): AxiosPromise<CurrencySingle> {
            return localVarFp.updateCurrency(code, currencyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * Make this currency the default currency for the user. If the currency is not enabled, it will be enabled as well.
     * @summary Make currency default currency.
     * @param {string} code The currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public defaultCurrency(code: string, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).defaultCurrency(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a currency.
     * @summary Delete a currency.
     * @param {string} code The currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public deleteCurrency(code: string, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).deleteCurrency(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a currency.
     * @summary Disable a currency.
     * @param {number} code The currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public disableCurrency(code: number, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).disableCurrency(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a single currency.
     * @summary Enable a single currency.
     * @param {string} code The currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public enableCurrency(code: string, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).enableCurrency(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single currency.
     * @summary Get a single currency.
     * @param {string} code The currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCurrency(code: string, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).getCurrency(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s default currency.
     * @summary Get the user\'s default currency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getDefaultCurrency(options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).getDefaultCurrency(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all accounts with this currency.
     * @summary List all accounts with this currency.
     * @param {string} code The currency code.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [date] A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account\&#39;s balance on that day. 
     * @param {AccountTypeFilter} [type] Optional filter on the account type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listAccountByCurrency(code: string, page?: number, date?: string, type?: AccountTypeFilter, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listAccountByCurrency(code, page, date, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all available budgets with this currency.
     * @summary List all available budgets with this currency.
     * @param {string} code The currency code.
     * @param {number} [page] Page number. The default pagination is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listAvailableBudgetByCurrency(code: string, page?: number, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listAvailableBudgetByCurrency(code, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all bills with this currency.
     * @summary List all bills with this currency.
     * @param {string} code The currency code.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listBillByCurrency(code: string, page?: number, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listBillByCurrency(code, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all budget limits with this currency
     * @summary List all budget limits with this currency
     * @param {string} code The currency code.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] Start date for the budget limit list.
     * @param {string} [end] End date for the budget limit list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listBudgetLimitByCurrency(code: string, page?: number, start?: string, end?: string, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listBudgetLimitByCurrency(code, page, start, end, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all currencies.
     * @summary List all currencies.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listCurrency(page?: number, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listCurrency(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all recurring transactions with this currency.
     * @summary List all recurring transactions with this currency.
     * @param {string} code The currency code.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listRecurrenceByCurrency(code: string, page?: number, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listRecurrenceByCurrency(code, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rules with this currency.
     * @summary List all rules with this currency.
     * @param {string} code The currency code.
     * @param {number} [page] Page number. The default pagination per 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listRuleByCurrency(code: string, page?: number, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listRuleByCurrency(code, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions with this currency.
     * @summary List all transactions with this currency.
     * @param {string} code The currency code.
     * @param {number} [page] Page number. The default pagination is per 50.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the list of transactions. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the list of transactions. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public listTransactionByCurrency(code: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).listTransactionByCurrency(code, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new currency
     * @param {CurrencyStore} currencyStore JSON array or key&#x3D;value pairs with the necessary currency information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public storeCurrency(currencyStore: CurrencyStore, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).storeCurrency(currencyStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing currency.
     * @summary Update existing currency.
     * @param {string} code The currency code.
     * @param {CurrencyUpdate} currencyUpdate JSON array with updated currency information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public updateCurrency(code: string, currencyUpdate: CurrencyUpdate, options?: AxiosRequestConfig) {
        return CurrenciesApiFp(this.configuration).updateCurrency(code, currencyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows you to update transactions in bulk. 
         * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} query The JSON query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateTransactions: async (query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('bulkUpdateTransactions', 'query', query)
            const localVarPath = `/api/v1/data/bulk/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A call to this endpoint permanently destroys the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint. 
         * @summary Endpoint to destroy user data
         * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyData: async (objects: DataDestroyObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objects' is not null or undefined
            assertParamExists('destroyData', 'objects', objects)
            const localVarPath = `/api/v1/data/destroy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (objects !== undefined) {
                localVarQueryParameter['objects'] = objects;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export account data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAccounts: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export bills from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBills: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/bills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export budgets and budget amount data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBudgets: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export category data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCategories: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export piggy banks from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPiggies: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/piggy-banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export recurring transaction data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRecurring: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export rule groups and rule data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRules: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export tag data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTags: async (type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/export/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export transaction data from Firefly III
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped. 
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactions: async (start: string, end: string, accounts?: string, type?: ExportFileFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('exportTransactions', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('exportTransactions', 'end', end)
            const localVarPath = `/api/v1/data/export/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows you to update transactions in bulk. 
         * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} query The JSON query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateTransactions(query: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateTransactions(query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A call to this endpoint permanently destroys the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint. 
         * @summary Endpoint to destroy user data
         * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyData(objects: DataDestroyObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyData(objects, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export account data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportAccounts(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportAccounts(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export bills from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportBills(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportBills(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export budgets and budget amount data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportBudgets(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportBudgets(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export category data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportCategories(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportCategories(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export piggy banks from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportPiggies(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportPiggies(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export recurring transaction data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportRecurring(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportRecurring(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export rule groups and rule data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportRules(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportRules(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export tag data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportTags(type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportTags(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export transaction data from Firefly III
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped. 
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportTransactions(start: string, end: string, accounts?: string, type?: ExportFileFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportTransactions(start, end, accounts, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Allows you to update transactions in bulk. 
         * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} query The JSON query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateTransactions(query: string, options?: any): AxiosPromise<void> {
            return localVarFp.bulkUpdateTransactions(query, options).then((request) => request(axios, basePath));
        },
        /**
         * A call to this endpoint permanently destroys the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint. 
         * @summary Endpoint to destroy user data
         * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyData(objects: DataDestroyObject, options?: any): AxiosPromise<void> {
            return localVarFp.destroyData(objects, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export account data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAccounts(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportAccounts(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export bills from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBills(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportBills(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export budgets and budget amount data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBudgets(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportBudgets(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export category data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCategories(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportCategories(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export piggy banks from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPiggies(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportPiggies(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export recurring transaction data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRecurring(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportRecurring(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export rule groups and rule data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportRules(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportRules(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export tag data from Firefly III
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTags(type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportTags(type, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only. 
         * @summary Export transaction data from Firefly III
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped. 
         * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactions(start: string, end: string, accounts?: string, type?: ExportFileFilter, options?: any): AxiosPromise<any> {
            return localVarFp.exportTransactions(start, end, accounts, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Allows you to update transactions in bulk. 
     * @summary Bulk update transaction properties. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
     * @param {string} query The JSON query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public bulkUpdateTransactions(query: string, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).bulkUpdateTransactions(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A call to this endpoint permanently destroys the requested data type. Use it with care and always with user permission. The demo user is incapable of using this endpoint. 
     * @summary Endpoint to destroy user data
     * @param {DataDestroyObject} objects The type of data that you wish to destroy. You can only use one at a time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public destroyData(objects: DataDestroyObject, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).destroyData(objects, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your accounts from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export account data from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportAccounts(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportAccounts(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your bills from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export bills from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportBills(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportBills(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your budgets and associated budget data from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export budgets and budget amount data from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportBudgets(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportBudgets(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your categories from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export category data from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportCategories(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportCategories(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your piggy banks from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export piggy banks from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportPiggies(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportPiggies(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your recurring transactions from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export recurring transaction data from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportRecurring(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportRecurring(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your rules and rule groups from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export rule groups and rule data from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportRules(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportRules(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export your tags from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export tag data from Firefly III
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportTags(type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportTags(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to export transactions from Firefly III into a file. Currently supports CSV exports only. 
     * @summary Export transaction data from Firefly III
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {string} [accounts] Limit the export of transactions to these accounts only. Only asset accounts will be accepted. Other types will be silently dropped. 
     * @param {ExportFileFilter} [type] The file type the export file (CSV is currently the only option).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public exportTransactions(start: string, end: string, accounts?: string, type?: ExportFileFilter, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).exportTransactions(start, end, accounts, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightApi - axios parameter creator
 * @export
 */
export const InsightApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
         * @summary Insight into expenses, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseAsset: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseAsset', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseAsset', 'end', end)
            const localVarPath = `/api/v1/insight/expense/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
         * @summary Insight into expenses, grouped by bill.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [bills] The bills to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBill: async (start: string, end: string, bills?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseBill', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseBill', 'end', end)
            const localVarPath = `/api/v1/insight/expense/bill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (bills) {
                localVarQueryParameter['bills[]'] = bills;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
         * @summary Insight into expenses, grouped by budget.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [budgets] The budgets to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBudget: async (start: string, end: string, budgets?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseBudget', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseBudget', 'end', end)
            const localVarPath = `/api/v1/insight/expense/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (budgets) {
                localVarQueryParameter['budgets[]'] = budgets;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
         * @summary Insight into expenses, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseCategory: async (start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseCategory', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseCategory', 'end', end)
            const localVarPath = `/api/v1/insight/expense/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (categories) {
                localVarQueryParameter['categories[]'] = categories;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
         * @summary Insight into expenses, grouped by expense account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseExpense: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseExpense', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseExpense', 'end', end)
            const localVarPath = `/api/v1/insight/expense/expense`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
         * @summary Insight into expenses, without bill.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBill: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseNoBill', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseNoBill', 'end', end)
            const localVarPath = `/api/v1/insight/expense/no-bill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
         * @summary Insight into expenses, without budget.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBudget: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseNoBudget', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseNoBudget', 'end', end)
            const localVarPath = `/api/v1/insight/expense/no-budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
         * @summary Insight into expenses, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoCategory: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseNoCategory', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseNoCategory', 'end', end)
            const localVarPath = `/api/v1/insight/expense/no-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoTag: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseNoTag', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseNoTag', 'end', end)
            const localVarPath = `/api/v1/insight/expense/no-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
         * @summary Insight into expenses, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTag: async (start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseTag', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseTag', 'end', end)
            const localVarPath = `/api/v1/insight/expense/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (tags) {
                localVarQueryParameter['tags[]'] = tags;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a sum of the total expenses made by the user. 
         * @summary Insight into total expenses.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTotal: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightExpenseTotal', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightExpenseTotal', 'end', end)
            const localVarPath = `/api/v1/insight/expense/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by asset account. 
         * @summary Insight into income, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeAsset: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightIncomeAsset', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightIncomeAsset', 'end', end)
            const localVarPath = `/api/v1/insight/income/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) category. 
         * @summary Insight into income, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeCategory: async (start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightIncomeCategory', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightIncomeCategory', 'end', end)
            const localVarPath = `/api/v1/insight/income/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (categories) {
                localVarQueryParameter['categories[]'] = categories;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no category. 
         * @summary Insight into income, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoCategory: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightIncomeNoCategory', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightIncomeNoCategory', 'end', end)
            const localVarPath = `/api/v1/insight/income/no-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no tag. 
         * @summary Insight into income, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoTag: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightIncomeNoTag', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightIncomeNoTag', 'end', end)
            const localVarPath = `/api/v1/insight/income/no-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by revenue account. 
         * @summary Insight into income, grouped by revenue account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeRevenue: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightIncomeRevenue', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightIncomeRevenue', 'end', end)
            const localVarPath = `/api/v1/insight/income/revenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
         * @summary Insight into income, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTag: async (start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightIncomeTag', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightIncomeTag', 'end', end)
            const localVarPath = `/api/v1/insight/income/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (tags) {
                localVarQueryParameter['tags[]'] = tags;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a sum of the total income received by the user. 
         * @summary Insight into total income.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTotal: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightIncomeTotal', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightIncomeTotal', 'end', end)
            const localVarPath = `/api/v1/insight/income/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
         * @summary Insight into transfers, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferCategory: async (start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightTransferCategory', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightTransferCategory', 'end', end)
            const localVarPath = `/api/v1/insight/transfer/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (categories) {
                localVarQueryParameter['categories[]'] = categories;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
         * @summary Insight into transfers, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoCategory: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightTransferNoCategory', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightTransferNoCategory', 'end', end)
            const localVarPath = `/api/v1/insight/transfer/no-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoTag: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightTransferNoTag', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightTransferNoTag', 'end', end)
            const localVarPath = `/api/v1/insight/transfer/no-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
         * @summary Insight into transfers, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTag: async (start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightTransferTag', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightTransferTag', 'end', end)
            const localVarPath = `/api/v1/insight/transfer/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (tags) {
                localVarQueryParameter['tags[]'] = tags;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a sum of the total amount transfers made by the user. 
         * @summary Insight into total transfers.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTotal: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightTransferTotal', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightTransferTotal', 'end', end)
            const localVarPath = `/api/v1/insight/transfer/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
         * @summary Insight into transfers, grouped by account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransfers: async (start: string, end: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('insightTransfers', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('insightTransfers', 'end', end)
            const localVarPath = `/api/v1/insight/transfer/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightApi - functional programming interface
 * @export
 */
export const InsightApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
         * @summary Insight into expenses, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseAsset(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseAsset(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
         * @summary Insight into expenses, grouped by bill.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [bills] The bills to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseBill(start: string, end: string, bills?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseBill(start, end, bills, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
         * @summary Insight into expenses, grouped by budget.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [budgets] The budgets to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseBudget(start: string, end: string, budgets?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseBudget(start, end, budgets, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
         * @summary Insight into expenses, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseCategory(start, end, categories, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
         * @summary Insight into expenses, grouped by expense account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseExpense(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseExpense(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
         * @summary Insight into expenses, without bill.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseNoBill(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseNoBill(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
         * @summary Insight into expenses, without budget.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseNoBudget(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseNoBudget(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
         * @summary Insight into expenses, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseNoCategory(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseNoCategory(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseNoTag(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseNoTag(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
         * @summary Insight into expenses, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseTag(start, end, tags, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a sum of the total expenses made by the user. 
         * @summary Insight into total expenses.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightExpenseTotal(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightExpenseTotal(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by asset account. 
         * @summary Insight into income, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightIncomeAsset(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightIncomeAsset(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) category. 
         * @summary Insight into income, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightIncomeCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightIncomeCategory(start, end, categories, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no category. 
         * @summary Insight into income, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightIncomeNoCategory(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightIncomeNoCategory(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no tag. 
         * @summary Insight into income, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightIncomeNoTag(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightIncomeNoTag(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by revenue account. 
         * @summary Insight into income, grouped by revenue account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightIncomeRevenue(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightIncomeRevenue(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
         * @summary Insight into income, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightIncomeTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightIncomeTag(start, end, tags, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a sum of the total income received by the user. 
         * @summary Insight into total income.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightIncomeTotal(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightIncomeTotal(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
         * @summary Insight into transfers, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightTransferCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightTransferCategory(start, end, categories, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
         * @summary Insight into transfers, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightTransferNoCategory(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightTransferNoCategory(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightTransferNoTag(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightTransferNoTag(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
         * @summary Insight into transfers, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightTransferTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightGroupEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightTransferTag(start, end, tags, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a sum of the total amount transfers made by the user. 
         * @summary Insight into total transfers.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightTransferTotal(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTotalEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightTransferTotal(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
         * @summary Insight into transfers, grouped by account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightTransfers(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InsightTransferEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightTransfers(start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightApi - factory interface
 * @export
 */
export const InsightApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightApiFp(configuration)
    return {
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
         * @summary Insight into expenses, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseAsset(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightExpenseAsset(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
         * @summary Insight into expenses, grouped by bill.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [bills] The bills to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBill(start: string, end: string, bills?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightExpenseBill(start, end, bills, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
         * @summary Insight into expenses, grouped by budget.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [budgets] The budgets to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseBudget(start: string, end: string, budgets?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightExpenseBudget(start, end, budgets, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
         * @summary Insight into expenses, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightExpenseCategory(start, end, categories, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
         * @summary Insight into expenses, grouped by expense account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseExpense(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightExpenseExpense(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
         * @summary Insight into expenses, without bill.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBill(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightExpenseNoBill(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
         * @summary Insight into expenses, without budget.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoBudget(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightExpenseNoBudget(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
         * @summary Insight into expenses, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoCategory(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightExpenseNoCategory(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseNoTag(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightExpenseNoTag(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
         * @summary Insight into expenses, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightExpenseTag(start, end, tags, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a sum of the total expenses made by the user. 
         * @summary Insight into total expenses.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightExpenseTotal(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightExpenseTotal(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by asset account. 
         * @summary Insight into income, grouped by asset account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeAsset(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightIncomeAsset(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) category. 
         * @summary Insight into income, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightIncomeCategory(start, end, categories, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no category. 
         * @summary Insight into income, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoCategory(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightIncomeNoCategory(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, including only income with no tag. 
         * @summary Insight into income, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeNoTag(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightIncomeNoTag(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by revenue account. 
         * @summary Insight into income, grouped by revenue account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeRevenue(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightIncomeRevenue(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
         * @summary Insight into income, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightIncomeTag(start, end, tags, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a sum of the total income received by the user. 
         * @summary Insight into total income.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightIncomeTotal(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightIncomeTotal(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
         * @summary Insight into transfers, grouped by category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [categories] The categories to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightTransferCategory(start, end, categories, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
         * @summary Insight into transfers, without category.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoCategory(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightTransferNoCategory(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
         * @summary Insight into expenses, without tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferNoTag(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightTransferNoTag(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
         * @summary Insight into transfers, grouped by tag.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [tags] The tags to be included in the results. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightGroupEntry>> {
            return localVarFp.insightTransferTag(start, end, tags, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a sum of the total amount transfers made by the user. 
         * @summary Insight into total transfers.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransferTotal(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTotalEntry>> {
            return localVarFp.insightTransferTotal(start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
         * @summary Insight into transfers, grouped by account.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightTransfers(start: string, end: string, accounts?: Array<number>, options?: any): AxiosPromise<Array<InsightTransferEntry>> {
            return localVarFp.insightTransfers(start, end, accounts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightApi - object-oriented interface
 * @export
 * @class InsightApi
 * @extends {BaseAPI}
 */
export class InsightApi extends BaseAPI {
    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
     * @summary Insight into expenses, grouped by asset account.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseAsset(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseAsset(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
     * @summary Insight into expenses, grouped by bill.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [bills] The bills to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseBill(start: string, end: string, bills?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseBill(start, end, bills, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
     * @summary Insight into expenses, grouped by budget.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [budgets] The budgets to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseBudget(start: string, end: string, budgets?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseBudget(start, end, budgets, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
     * @summary Insight into expenses, grouped by category.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [categories] The categories to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseCategory(start, end, categories, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
     * @summary Insight into expenses, grouped by expense account.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of expense accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID\&#39;s. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseExpense(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseExpense(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
     * @summary Insight into expenses, without bill.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseNoBill(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseNoBill(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
     * @summary Insight into expenses, without budget.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseNoBudget(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseNoBudget(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
     * @summary Insight into expenses, without category.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseNoCategory(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseNoCategory(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
     * @summary Insight into expenses, without tag.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseNoTag(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseNoTag(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
     * @summary Insight into expenses, grouped by tag.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [tags] The tags to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseTag(start, end, tags, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a sum of the total expenses made by the user. 
     * @summary Insight into total expenses.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightExpenseTotal(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightExpenseTotal(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the income received by the user, grouped by asset account. 
     * @summary Insight into income, grouped by asset account.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightIncomeAsset(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightIncomeAsset(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the income received by the user, grouped by (any) category. 
     * @summary Insight into income, grouped by category.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [categories] The categories to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightIncomeCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightIncomeCategory(start, end, categories, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the income received by the user, including only income with no category. 
     * @summary Insight into income, without category.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightIncomeNoCategory(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightIncomeNoCategory(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the income received by the user, including only income with no tag. 
     * @summary Insight into income, without tag.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightIncomeNoTag(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightIncomeNoTag(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the income received by the user, grouped by revenue account. 
     * @summary Insight into income, grouped by revenue account.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you add the accounts ID\&#39;s of revenue accounts, only those accounts are included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID\&#39;s. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightIncomeRevenue(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightIncomeRevenue(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
     * @summary Insight into income, grouped by tag.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [tags] The tags to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightIncomeTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightIncomeTag(start, end, tags, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a sum of the total income received by the user. 
     * @summary Insight into total income.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightIncomeTotal(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightIncomeTotal(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
     * @summary Insight into transfers, grouped by category.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [categories] The categories to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightTransferCategory(start: string, end: string, categories?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightTransferCategory(start, end, categories, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
     * @summary Insight into transfers, without category.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightTransferNoCategory(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightTransferNoCategory(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
     * @summary Insight into expenses, without tag.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightTransferNoTag(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightTransferNoTag(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
     * @summary Insight into transfers, grouped by tag.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [tags] The tags to be included in the results. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightTransferTag(start: string, end: string, tags?: Array<number>, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightTransferTag(start, end, tags, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a sum of the total amount transfers made by the user. 
     * @summary Insight into total transfers.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightTransferTotal(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightTransferTotal(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
     * @summary Insight into transfers, grouped by account.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {Array<number>} [accounts] The accounts to be included in the results. If you include ID\&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID\&#39;s will be ignored. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightApi
     */
    public insightTransfers(start: string, end: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return InsightApiFp(this.configuration).insightTransfers(start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LinksApi - axios parameter creator
 * @export
 */
export const LinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it. 
         * @summary Permanently delete link type.
         * @param {string} id The ID of the link type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLinkType: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLinkType', 'id', id)
            const localVarPath = `/api/v1/link_types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will permanently delete link. Transactions remain. 
         * @summary Permanently delete link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionLink: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransactionLink', 'id', id)
            const localVarPath = `/api/v1/transaction_links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single link type by its ID. 
         * @summary Get single a link type.
         * @param {string} id The ID of the link type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkType: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLinkType', 'id', id)
            const localVarPath = `/api/v1/link_types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single link by its ID. 
         * @summary Get a single link.
         * @param {string} id The ID of the transaction link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLink: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionLink', 'id', id)
            const localVarPath = `/api/v1/transaction_links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the link types the system has. These include the default ones as well as any new ones. 
         * @summary List all types of links.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinkType: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/link_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions under this link type, both the inward and outward transactions. 
         * @summary List all transactions under this link type.
         * @param {string} id The ID of the link type.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByLinkType: async (id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByLinkType', 'id', id)
            const localVarPath = `/api/v1/link_types/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the transaction links. 
         * @summary List all transaction links.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionLink: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/transaction_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create a new link type
         * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLinkType: async (linkType: LinkType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkType' is not null or undefined
            assertParamExists('storeLinkType', 'linkType', linkType)
            const localVarPath = `/api/v1/link_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
         * @summary Create a new link between transactions
         * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransactionLink: async (transactionLinkStore: TransactionLinkStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionLinkStore' is not null or undefined
            assertParamExists('storeTransactionLink', 'transactionLinkStore', transactionLinkStore)
            const localVarPath = `/api/v1/transaction_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionLinkStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it. 
         * @summary Update existing link type.
         * @param {string} id The ID of the link type.
         * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkType: async (id: string, linkTypeUpdate: LinkTypeUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLinkType', 'id', id)
            // verify required parameter 'linkTypeUpdate' is not null or undefined
            assertParamExists('updateLinkType', 'linkTypeUpdate', linkTypeUpdate)
            const localVarPath = `/api/v1/link_types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkTypeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to update a single existing link. 
         * @summary Update an existing link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionLink: async (id: string, transactionLinkUpdate: TransactionLinkUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransactionLink', 'id', id)
            // verify required parameter 'transactionLinkUpdate' is not null or undefined
            assertParamExists('updateTransactionLink', 'transactionLinkUpdate', transactionLinkUpdate)
            const localVarPath = `/api/v1/transaction_links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionLinkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LinksApi - functional programming interface
 * @export
 */
export const LinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LinksApiAxiosParamCreator(configuration)
    return {
        /**
         * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it. 
         * @summary Permanently delete link type.
         * @param {string} id The ID of the link type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLinkType(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLinkType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Will permanently delete link. Transactions remain. 
         * @summary Permanently delete link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionLink(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single link type by its ID. 
         * @summary Get single a link type.
         * @param {string} id The ID of the link type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkType(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTypeSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single link by its ID. 
         * @summary Get a single link.
         * @param {string} id The ID of the transaction link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionLink(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionLinkSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the link types the system has. These include the default ones as well as any new ones. 
         * @summary List all types of links.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLinkType(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTypeArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLinkType(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions under this link type, both the inward and outward transactions. 
         * @summary List all transactions under this link type.
         * @param {string} id The ID of the link type.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByLinkType(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByLinkType(id, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the transaction links. 
         * @summary List all transaction links.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionLink(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionLinkArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionLink(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create a new link type
         * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeLinkType(linkType: LinkType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTypeSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeLinkType(linkType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
         * @summary Create a new link between transactions
         * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeTransactionLink(transactionLinkStore: TransactionLinkStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionLinkSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeTransactionLink(transactionLinkStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it. 
         * @summary Update existing link type.
         * @param {string} id The ID of the link type.
         * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLinkType(id: string, linkTypeUpdate: LinkTypeUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTypeSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLinkType(id, linkTypeUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used to update a single existing link. 
         * @summary Update an existing link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactionLink(id: string, transactionLinkUpdate: TransactionLinkUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionLinkSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactionLink(id, transactionLinkUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LinksApi - factory interface
 * @export
 */
export const LinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LinksApiFp(configuration)
    return {
        /**
         * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it. 
         * @summary Permanently delete link type.
         * @param {string} id The ID of the link type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLinkType(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLinkType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Will permanently delete link. Transactions remain. 
         * @summary Permanently delete link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionLink(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransactionLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single link type by its ID. 
         * @summary Get single a link type.
         * @param {string} id The ID of the link type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkType(id: string, options?: any): AxiosPromise<LinkTypeSingle> {
            return localVarFp.getLinkType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single link by its ID. 
         * @summary Get a single link.
         * @param {string} id The ID of the transaction link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionLink(id: string, options?: any): AxiosPromise<TransactionLinkSingle> {
            return localVarFp.getTransactionLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the link types the system has. These include the default ones as well as any new ones. 
         * @summary List all types of links.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinkType(page?: number, options?: any): AxiosPromise<LinkTypeArray> {
            return localVarFp.listLinkType(page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions under this link type, both the inward and outward transactions. 
         * @summary List all transactions under this link type.
         * @param {string} id The ID of the link type.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByLinkType(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByLinkType(id, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the transaction links. 
         * @summary List all transaction links.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionLink(page?: number, options?: any): AxiosPromise<TransactionLinkArray> {
            return localVarFp.listTransactionLink(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
         * @summary Create a new link type
         * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLinkType(linkType: LinkType, options?: any): AxiosPromise<LinkTypeSingle> {
            return localVarFp.storeLinkType(linkType, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
         * @summary Create a new link between transactions
         * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransactionLink(transactionLinkStore: TransactionLinkStore, options?: any): AxiosPromise<TransactionLinkSingle> {
            return localVarFp.storeTransactionLink(transactionLinkStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it. 
         * @summary Update existing link type.
         * @param {string} id The ID of the link type.
         * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkType(id: string, linkTypeUpdate: LinkTypeUpdate, options?: any): AxiosPromise<LinkTypeSingle> {
            return localVarFp.updateLinkType(id, linkTypeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to update a single existing link. 
         * @summary Update an existing link between transactions.
         * @param {string} id The ID of the transaction link.
         * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionLink(id: string, transactionLinkUpdate: TransactionLinkUpdate, options?: any): AxiosPromise<TransactionLinkSingle> {
            return localVarFp.updateTransactionLink(id, transactionLinkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LinksApi - object-oriented interface
 * @export
 * @class LinksApi
 * @extends {BaseAPI}
 */
export class LinksApi extends BaseAPI {
    /**
     * Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it. 
     * @summary Permanently delete link type.
     * @param {string} id The ID of the link type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public deleteLinkType(id: string, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).deleteLinkType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will permanently delete link. Transactions remain. 
     * @summary Permanently delete link between transactions.
     * @param {string} id The ID of the transaction link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public deleteTransactionLink(id: string, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).deleteTransactionLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single link type by its ID. 
     * @summary Get single a link type.
     * @param {string} id The ID of the link type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public getLinkType(id: string, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).getLinkType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single link by its ID. 
     * @summary Get a single link.
     * @param {string} id The ID of the transaction link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public getTransactionLink(id: string, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).getTransactionLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the link types the system has. These include the default ones as well as any new ones. 
     * @summary List all types of links.
     * @param {number} [page] Page number. The default pagination is 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public listLinkType(page?: number, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).listLinkType(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions under this link type, both the inward and outward transactions. 
     * @summary List all transactions under this link type.
     * @param {string} id The ID of the link type.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the results. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the results. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public listTransactionByLinkType(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).listTransactionByLinkType(id, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the transaction links. 
     * @summary List all transaction links.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public listTransactionLink(page?: number, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).listTransactionLink(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform).
     * @summary Create a new link type
     * @param {LinkType} linkType JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public storeLinkType(linkType: LinkType, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).storeLinkType(linkType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Store a new link between two transactions. For this end point you need the journal_id from a transaction.
     * @summary Create a new link between transactions
     * @param {TransactionLinkStore} transactionLinkStore JSON array with the necessary link type information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public storeTransactionLink(transactionLinkStore: TransactionLinkStore, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).storeTransactionLink(transactionLinkStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it. 
     * @summary Update existing link type.
     * @param {string} id The ID of the link type.
     * @param {LinkTypeUpdate} linkTypeUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public updateLinkType(id: string, linkTypeUpdate: LinkTypeUpdate, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).updateLinkType(id, linkTypeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to update a single existing link. 
     * @summary Update an existing link between transactions.
     * @param {string} id The ID of the transaction link.
     * @param {TransactionLinkUpdate} transactionLinkUpdate JSON array or formdata with updated link type information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LinksApi
     */
    public updateTransactionLink(id: string, transactionLinkUpdate: TransactionLinkUpdate, options?: AxiosRequestConfig) {
        return LinksApiFp(this.configuration).updateTransactionLink(id, transactionLinkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ObjectGroupsApi - axios parameter creator
 * @export
 */
export const ObjectGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a object group.
         * @summary Delete a object group.
         * @param {string} id The ID of the object group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteObjectGroup', 'id', id)
            const localVarPath = `/api/v1/object_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single object group.
         * @summary Get a single object group.
         * @param {string} id The ID of the object group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getObjectGroup', 'id', id)
            const localVarPath = `/api/v1/object_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all bills with this object group.
         * @summary List all bills with this object group.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByObjectGroup: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listBillByObjectGroup', 'id', id)
            const localVarPath = `/api/v1/object_groups/{id}/bills`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all oject groups.
         * @summary List all oject groups.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjectGroups: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/object_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the object group. 
         * @summary List all piggy banks related to the object group.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByObjectGroup: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listPiggyBankByObjectGroup', 'id', id)
            const localVarPath = `/api/v1/object_groups/{id}/piggy_banks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing object group.
         * @summary Update existing object group.
         * @param {string} id The ID of the object group
         * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectGroup: async (id: string, objectGroupUpdate: ObjectGroupUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateObjectGroup', 'id', id)
            // verify required parameter 'objectGroupUpdate' is not null or undefined
            assertParamExists('updateObjectGroup', 'objectGroupUpdate', objectGroupUpdate)
            const localVarPath = `/api/v1/object_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(objectGroupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectGroupsApi - functional programming interface
 * @export
 */
export const ObjectGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjectGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a object group.
         * @summary Delete a object group.
         * @param {string} id The ID of the object group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObjectGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteObjectGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single object group.
         * @summary Get a single object group.
         * @param {string} id The ID of the object group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObjectGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObjectGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all bills with this object group.
         * @summary List all bills with this object group.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBillByObjectGroup(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBillByObjectGroup(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all oject groups.
         * @summary List all oject groups.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listObjectGroups(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectGroupArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listObjectGroups(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the object group. 
         * @summary List all piggy banks related to the object group.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPiggyBankByObjectGroup(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPiggyBankByObjectGroup(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing object group.
         * @summary Update existing object group.
         * @param {string} id The ID of the object group
         * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateObjectGroup(id: string, objectGroupUpdate: ObjectGroupUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateObjectGroup(id, objectGroupUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ObjectGroupsApi - factory interface
 * @export
 */
export const ObjectGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjectGroupsApiFp(configuration)
    return {
        /**
         * Delete a object group.
         * @summary Delete a object group.
         * @param {string} id The ID of the object group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObjectGroup(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteObjectGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single object group.
         * @summary Get a single object group.
         * @param {string} id The ID of the object group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectGroup(id: string, options?: any): AxiosPromise<ObjectGroupSingle> {
            return localVarFp.getObjectGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all bills with this object group.
         * @summary List all bills with this object group.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBillByObjectGroup(id: string, page?: number, options?: any): AxiosPromise<BillArray> {
            return localVarFp.listBillByObjectGroup(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all oject groups.
         * @summary List all oject groups.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjectGroups(page?: number, options?: any): AxiosPromise<ObjectGroupArray> {
            return localVarFp.listObjectGroups(page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the piggy banks connected to the object group. 
         * @summary List all piggy banks related to the object group.
         * @param {string} id The ID of the account.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBankByObjectGroup(id: string, page?: number, options?: any): AxiosPromise<PiggyBankArray> {
            return localVarFp.listPiggyBankByObjectGroup(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing object group.
         * @summary Update existing object group.
         * @param {string} id The ID of the object group
         * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateObjectGroup(id: string, objectGroupUpdate: ObjectGroupUpdate, options?: any): AxiosPromise<ObjectGroupSingle> {
            return localVarFp.updateObjectGroup(id, objectGroupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjectGroupsApi - object-oriented interface
 * @export
 * @class ObjectGroupsApi
 * @extends {BaseAPI}
 */
export class ObjectGroupsApi extends BaseAPI {
    /**
     * Delete a object group.
     * @summary Delete a object group.
     * @param {string} id The ID of the object group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    public deleteObjectGroup(id: string, options?: AxiosRequestConfig) {
        return ObjectGroupsApiFp(this.configuration).deleteObjectGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single object group.
     * @summary Get a single object group.
     * @param {string} id The ID of the object group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    public getObjectGroup(id: string, options?: AxiosRequestConfig) {
        return ObjectGroupsApiFp(this.configuration).getObjectGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all bills with this object group.
     * @summary List all bills with this object group.
     * @param {string} id The ID of the account.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    public listBillByObjectGroup(id: string, page?: number, options?: AxiosRequestConfig) {
        return ObjectGroupsApiFp(this.configuration).listBillByObjectGroup(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all oject groups.
     * @summary List all oject groups.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    public listObjectGroups(page?: number, options?: AxiosRequestConfig) {
        return ObjectGroupsApiFp(this.configuration).listObjectGroups(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the piggy banks connected to the object group. 
     * @summary List all piggy banks related to the object group.
     * @param {string} id The ID of the account.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    public listPiggyBankByObjectGroup(id: string, page?: number, options?: AxiosRequestConfig) {
        return ObjectGroupsApiFp(this.configuration).listPiggyBankByObjectGroup(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing object group.
     * @summary Update existing object group.
     * @param {string} id The ID of the object group
     * @param {ObjectGroupUpdate} objectGroupUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectGroupsApi
     */
    public updateObjectGroup(id: string, objectGroupUpdate: ObjectGroupUpdate, options?: AxiosRequestConfig) {
        return ObjectGroupsApiFp(this.configuration).updateObjectGroup(id, objectGroupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PiggyBanksApi - axios parameter creator
 * @export
 */
export const PiggyBanksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a piggy bank.
         * @summary Delete a piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePiggyBank: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePiggyBank', 'id', id)
            const localVarPath = `/api/v1/piggy_banks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single piggy bank.
         * @summary Get a single piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggyBank: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPiggyBank', 'id', id)
            const localVarPath = `/api/v1/piggy_banks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the piggy bank.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByPiggyBank: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByPiggyBank', 'id', id)
            const localVarPath = `/api/v1/piggy_banks/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all events linked to a piggy bank (adding and removing money).
         * @summary List all events linked to a piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByPiggyBank: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listEventByPiggyBank', 'id', id)
            const localVarPath = `/api/v1/piggy_banks/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all piggy banks.
         * @summary List all piggy banks.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBank: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/piggy_banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new piggy bank
         * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePiggyBank: async (piggyBankStore: PiggyBankStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piggyBankStore' is not null or undefined
            assertParamExists('storePiggyBank', 'piggyBankStore', piggyBankStore)
            const localVarPath = `/api/v1/piggy_banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piggyBankStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing piggy bank.
         * @summary Update existing piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePiggyBank: async (id: string, piggyBankUpdate: PiggyBankUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePiggyBank', 'id', id)
            // verify required parameter 'piggyBankUpdate' is not null or undefined
            assertParamExists('updatePiggyBank', 'piggyBankUpdate', piggyBankUpdate)
            const localVarPath = `/api/v1/piggy_banks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piggyBankUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PiggyBanksApi - functional programming interface
 * @export
 */
export const PiggyBanksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PiggyBanksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a piggy bank.
         * @summary Delete a piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePiggyBank(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePiggyBank(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single piggy bank.
         * @summary Get a single piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPiggyBank(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPiggyBank(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the piggy bank.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByPiggyBank(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByPiggyBank(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all events linked to a piggy bank (adding and removing money).
         * @summary List all events linked to a piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventByPiggyBank(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankEventArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventByPiggyBank(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all piggy banks.
         * @summary List all piggy banks.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPiggyBank(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPiggyBank(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new piggy bank
         * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storePiggyBank(piggyBankStore: PiggyBankStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storePiggyBank(piggyBankStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing piggy bank.
         * @summary Update existing piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePiggyBank(id: string, piggyBankUpdate: PiggyBankUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePiggyBank(id, piggyBankUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PiggyBanksApi - factory interface
 * @export
 */
export const PiggyBanksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PiggyBanksApiFp(configuration)
    return {
        /**
         * Delete a piggy bank.
         * @summary Delete a piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePiggyBank(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePiggyBank(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single piggy bank.
         * @summary Get a single piggy bank.
         * @param {string} id The ID of the piggy bank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPiggyBank(id: string, options?: any): AxiosPromise<PiggyBankSingle> {
            return localVarFp.getPiggyBank(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the piggy bank.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByPiggyBank(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByPiggyBank(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all events linked to a piggy bank (adding and removing money).
         * @summary List all events linked to a piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByPiggyBank(id: string, page?: number, options?: any): AxiosPromise<PiggyBankEventArray> {
            return localVarFp.listEventByPiggyBank(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all piggy banks.
         * @summary List all piggy banks.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPiggyBank(page?: number, options?: any): AxiosPromise<PiggyBankArray> {
            return localVarFp.listPiggyBank(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new piggy bank
         * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePiggyBank(piggyBankStore: PiggyBankStore, options?: any): AxiosPromise<PiggyBankSingle> {
            return localVarFp.storePiggyBank(piggyBankStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing piggy bank.
         * @summary Update existing piggy bank.
         * @param {string} id The ID of the piggy bank
         * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePiggyBank(id: string, piggyBankUpdate: PiggyBankUpdate, options?: any): AxiosPromise<PiggyBankSingle> {
            return localVarFp.updatePiggyBank(id, piggyBankUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PiggyBanksApi - object-oriented interface
 * @export
 * @class PiggyBanksApi
 * @extends {BaseAPI}
 */
export class PiggyBanksApi extends BaseAPI {
    /**
     * Delete a piggy bank.
     * @summary Delete a piggy bank.
     * @param {string} id The ID of the piggy bank.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    public deletePiggyBank(id: string, options?: AxiosRequestConfig) {
        return PiggyBanksApiFp(this.configuration).deletePiggyBank(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single piggy bank.
     * @summary Get a single piggy bank.
     * @param {string} id The ID of the piggy bank.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    public getPiggyBank(id: string, options?: AxiosRequestConfig) {
        return PiggyBanksApiFp(this.configuration).getPiggyBank(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the piggy bank.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    public listAttachmentByPiggyBank(id: string, page?: number, options?: AxiosRequestConfig) {
        return PiggyBanksApiFp(this.configuration).listAttachmentByPiggyBank(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all events linked to a piggy bank (adding and removing money).
     * @summary List all events linked to a piggy bank.
     * @param {string} id The ID of the piggy bank
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    public listEventByPiggyBank(id: string, page?: number, options?: AxiosRequestConfig) {
        return PiggyBanksApiFp(this.configuration).listEventByPiggyBank(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all piggy banks.
     * @summary List all piggy banks.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    public listPiggyBank(page?: number, options?: AxiosRequestConfig) {
        return PiggyBanksApiFp(this.configuration).listPiggyBank(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new piggy bank
     * @param {PiggyBankStore} piggyBankStore JSON array or key&#x3D;value pairs with the necessary piggy bank information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    public storePiggyBank(piggyBankStore: PiggyBankStore, options?: AxiosRequestConfig) {
        return PiggyBanksApiFp(this.configuration).storePiggyBank(piggyBankStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing piggy bank.
     * @summary Update existing piggy bank.
     * @param {string} id The ID of the piggy bank
     * @param {PiggyBankUpdate} piggyBankUpdate JSON array with updated piggy bank information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PiggyBanksApi
     */
    public updatePiggyBank(id: string, piggyBankUpdate: PiggyBankUpdate, options?: AxiosRequestConfig) {
        return PiggyBanksApiFp(this.configuration).updatePiggyBank(id, piggyBankUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PreferencesApi - axios parameter creator
 * @export
 */
export const PreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a single preference and the value.
         * @summary Return a single preference.
         * @param {string} name The name of the preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreference: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPreference', 'name', name)
            const localVarPath = `/api/v1/preferences/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the preferences of the user.
         * @summary List all users preferences.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPreference: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
         * @summary Store a new preference for this user.
         * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePreference: async (preference: Preference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'preference' is not null or undefined
            assertParamExists('storePreference', 'preference', preference)
            const localVarPath = `/api/v1/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user\'s preference.
         * @summary Update preference
         * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
         * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreference: async (name: string, preferenceUpdate: PreferenceUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updatePreference', 'name', name)
            // verify required parameter 'preferenceUpdate' is not null or undefined
            assertParamExists('updatePreference', 'preferenceUpdate', preferenceUpdate)
            const localVarPath = `/api/v1/preferences/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preferenceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PreferencesApi - functional programming interface
 * @export
 */
export const PreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a single preference and the value.
         * @summary Return a single preference.
         * @param {string} name The name of the preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreference(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferenceSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreference(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the preferences of the user.
         * @summary List all users preferences.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPreference(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferenceArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPreference(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
         * @summary Store a new preference for this user.
         * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storePreference(preference: Preference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferenceSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storePreference(preference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user\'s preference.
         * @summary Update preference
         * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
         * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePreference(name: string, preferenceUpdate: PreferenceUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferenceSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreference(name, preferenceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PreferencesApi - factory interface
 * @export
 */
export const PreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PreferencesApiFp(configuration)
    return {
        /**
         * Return a single preference and the value.
         * @summary Return a single preference.
         * @param {string} name The name of the preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreference(name: string, options?: any): AxiosPromise<PreferenceSingle> {
            return localVarFp.getPreference(name, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the preferences of the user.
         * @summary List all users preferences.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPreference(page?: number, options?: any): AxiosPromise<PreferenceArray> {
            return localVarFp.listPreference(page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
         * @summary Store a new preference for this user.
         * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePreference(preference: Preference, options?: any): AxiosPromise<PreferenceSingle> {
            return localVarFp.storePreference(preference, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user\'s preference.
         * @summary Update preference
         * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
         * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreference(name: string, preferenceUpdate: PreferenceUpdate, options?: any): AxiosPromise<PreferenceSingle> {
            return localVarFp.updatePreference(name, preferenceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PreferencesApi - object-oriented interface
 * @export
 * @class PreferencesApi
 * @extends {BaseAPI}
 */
export class PreferencesApi extends BaseAPI {
    /**
     * Return a single preference and the value.
     * @summary Return a single preference.
     * @param {string} name The name of the preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public getPreference(name: string, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).getPreference(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the preferences of the user.
     * @summary List all users preferences.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public listPreference(page?: number, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).listPreference(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
     * @summary Store a new preference for this user.
     * @param {Preference} preference JSON array with the necessary preference information or key&#x3D;value pairs. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public storePreference(preference: Preference, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).storePreference(preference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user\'s preference.
     * @summary Update preference
     * @param {string} name The name of the preference. Will always overwrite. Will be created if it does not exist.
     * @param {PreferenceUpdate} preferenceUpdate JSON array or key&#x3D;value pairs with the necessary preference information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public updatePreference(name: string, preferenceUpdate: PreferenceUpdate, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).updatePreference(name, preferenceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecurrencesApi - axios parameter creator
 * @export
 */
export const RecurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
         * @summary Delete a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurrence: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRecurrence', 'id', id)
            const localVarPath = `/api/v1/recurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single recurring transaction.
         * @summary Get a single recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrence: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRecurrence', 'id', id)
            const localVarPath = `/api/v1/recurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all recurring transactions.
         * @summary List all recurring transactions.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrence: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/recurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
         * @summary List all transactions created by a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByRecurrence: async (id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listTransactionByRecurrence', 'id', id)
            const localVarPath = `/api/v1/recurrences/{id}/transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new recurring transaction
         * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRecurrence: async (recurrenceStore: RecurrenceStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recurrenceStore' is not null or undefined
            assertParamExists('storeRecurrence', 'recurrenceStore', recurrenceStore)
            const localVarPath = `/api/v1/recurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recurrenceStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing recurring transaction.
         * @summary Update existing recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurrence: async (id: string, recurrenceUpdate: RecurrenceUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecurrence', 'id', id)
            // verify required parameter 'recurrenceUpdate' is not null or undefined
            assertParamExists('updateRecurrence', 'recurrenceUpdate', recurrenceUpdate)
            const localVarPath = `/api/v1/recurrences/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recurrenceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecurrencesApi - functional programming interface
 * @export
 */
export const RecurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
         * @summary Delete a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecurrence(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecurrence(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single recurring transaction.
         * @summary Get a single recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecurrence(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurrenceSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecurrence(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all recurring transactions.
         * @summary List all recurring transactions.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecurrence(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurrenceArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecurrence(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
         * @summary List all transactions created by a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByRecurrence(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByRecurrence(id, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new recurring transaction
         * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeRecurrence(recurrenceStore: RecurrenceStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurrenceSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeRecurrence(recurrenceStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing recurring transaction.
         * @summary Update existing recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecurrence(id: string, recurrenceUpdate: RecurrenceUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurrenceSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecurrence(id, recurrenceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecurrencesApi - factory interface
 * @export
 */
export const RecurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecurrencesApiFp(configuration)
    return {
        /**
         * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
         * @summary Delete a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurrence(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRecurrence(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single recurring transaction.
         * @summary Get a single recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrence(id: string, options?: any): AxiosPromise<RecurrenceSingle> {
            return localVarFp.getRecurrence(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all recurring transactions.
         * @summary List all recurring transactions.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecurrence(page?: number, options?: any): AxiosPromise<RecurrenceArray> {
            return localVarFp.listRecurrence(page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
         * @summary List all transactions created by a recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByRecurrence(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByRecurrence(id, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new recurring transaction
         * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRecurrence(recurrenceStore: RecurrenceStore, options?: any): AxiosPromise<RecurrenceSingle> {
            return localVarFp.storeRecurrence(recurrenceStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing recurring transaction.
         * @summary Update existing recurring transaction.
         * @param {string} id The ID of the recurring transaction.
         * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurrence(id: string, recurrenceUpdate: RecurrenceUpdate, options?: any): AxiosPromise<RecurrenceSingle> {
            return localVarFp.updateRecurrence(id, recurrenceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecurrencesApi - object-oriented interface
 * @export
 * @class RecurrencesApi
 * @extends {BaseAPI}
 */
export class RecurrencesApi extends BaseAPI {
    /**
     * Delete a recurring transaction. Transactions created by the recurring transaction will not be deleted.
     * @summary Delete a recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    public deleteRecurrence(id: string, options?: AxiosRequestConfig) {
        return RecurrencesApiFp(this.configuration).deleteRecurrence(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single recurring transaction.
     * @summary Get a single recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    public getRecurrence(id: string, options?: AxiosRequestConfig) {
        return RecurrencesApiFp(this.configuration).getRecurrence(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all recurring transactions.
     * @summary List all recurring transactions.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    public listRecurrence(page?: number, options?: AxiosRequestConfig) {
        return RecurrencesApiFp(this.configuration).listRecurrence(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions created by a recurring transaction, optionally limited to the date ranges specified.
     * @summary List all transactions created by a recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
     * @param {string} [end] A date formatted YYYY-MM-DD. Both the start and end date must be present. 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    public listTransactionByRecurrence(id: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return RecurrencesApiFp(this.configuration).listTransactionByRecurrence(id, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new recurring transaction
     * @param {RecurrenceStore} recurrenceStore JSON array or key&#x3D;value pairs with the necessary recurring transaction information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    public storeRecurrence(recurrenceStore: RecurrenceStore, options?: AxiosRequestConfig) {
        return RecurrencesApiFp(this.configuration).storeRecurrence(recurrenceStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing recurring transaction.
     * @summary Update existing recurring transaction.
     * @param {string} id The ID of the recurring transaction.
     * @param {RecurrenceUpdate} recurrenceUpdate JSON array with updated recurring transaction information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurrencesApi
     */
    public updateRecurrence(id: string, recurrenceUpdate: RecurrenceUpdate, options?: AxiosRequestConfig) {
        return RecurrencesApiFp(this.configuration).updateRecurrence(id, recurrenceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuleGroupsApi - axios parameter creator
 * @export
 */
export const RuleGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRuleGroup: async (id: string, start?: string, end?: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fireRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByGroup: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRuleByGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}/rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleGroup: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rule_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRuleGroup: async (ruleGroupStore: RuleGroupStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleGroupStore' is not null or undefined
            assertParamExists('storeRuleGroup', 'ruleGroupStore', ruleGroupStore)
            const localVarPath = `/api/v1/rule_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleGroupStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRuleGroup: async (id: string, page?: number, start?: string, end?: string, searchLimit?: number, triggeredLimit?: number, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testRuleGroup', 'id', id)
            const localVarPath = `/api/v1/rule_groups/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (searchLimit !== undefined) {
                localVarQueryParameter['search_limit'] = searchLimit;
            }

            if (triggeredLimit !== undefined) {
                localVarQueryParameter['triggered_limit'] = triggeredLimit;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleGroup: async (id: string, ruleGroupUpdate: RuleGroupUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRuleGroup', 'id', id)
            // verify required parameter 'ruleGroupUpdate' is not null or undefined
            assertParamExists('updateRuleGroup', 'ruleGroupUpdate', ruleGroupUpdate)
            const localVarPath = `/api/v1/rule_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleGroupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleGroupsApi - functional programming interface
 * @export
 */
export const RuleGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuleGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRuleGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRuleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fireRuleGroup(id: string, start?: string, end?: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fireRuleGroup(id, start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuleGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleByGroup(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleByGroup(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuleGroup(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuleGroup(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeRuleGroup(ruleGroupStore: RuleGroupStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeRuleGroup(ruleGroupStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testRuleGroup(id: string, page?: number, start?: string, end?: string, searchLimit?: number, triggeredLimit?: number, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testRuleGroup(id, page, start, end, searchLimit, triggeredLimit, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRuleGroup(id: string, ruleGroupUpdate: RuleGroupUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroupSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRuleGroup(id, ruleGroupUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuleGroupsApi - factory interface
 * @export
 */
export const RuleGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuleGroupsApiFp(configuration)
    return {
        /**
         * Delete a rule group.
         * @summary Delete a rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuleGroup(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRuleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
         * @summary Fire the rule group on your transactions.
         * @param {string} id The ID of the rule group.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRuleGroup(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.fireRuleGroup(id, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single rule group. This does not include the rules. For that, see below.
         * @summary Get a single rule group.
         * @param {string} id The ID of the rule group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuleGroup(id: string, options?: any): AxiosPromise<RuleGroupSingle> {
            return localVarFp.getRuleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List rules in this rule group.
         * @summary List rules in this rule group.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleByGroup(id: string, page?: number, options?: any): AxiosPromise<RuleArray> {
            return localVarFp.listRuleByGroup(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rule groups.
         * @summary List all rule groups.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuleGroup(page?: number, options?: any): AxiosPromise<RuleGroupArray> {
            return localVarFp.listRuleGroup(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule group.
         * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRuleGroup(ruleGroupStore: RuleGroupStore, options?: any): AxiosPromise<RuleGroupSingle> {
            return localVarFp.storeRuleGroup(ruleGroupStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule group. No changes will be made.
         * @param {string} id The ID of the rule group.
         * @param {number} [page] Page number. The default pagination is 50 items.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
         * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
         * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRuleGroup(id: string, page?: number, start?: string, end?: string, searchLimit?: number, triggeredLimit?: number, accounts?: Array<number>, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.testRuleGroup(id, page, start, end, searchLimit, triggeredLimit, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing rule group.
         * @summary Update existing rule group.
         * @param {string} id The ID of the rule group.
         * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleGroup(id: string, ruleGroupUpdate: RuleGroupUpdate, options?: any): AxiosPromise<RuleGroupSingle> {
            return localVarFp.updateRuleGroup(id, ruleGroupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RuleGroupsApi - object-oriented interface
 * @export
 * @class RuleGroupsApi
 * @extends {BaseAPI}
 */
export class RuleGroupsApi extends BaseAPI {
    /**
     * Delete a rule group.
     * @summary Delete a rule group.
     * @param {string} id The ID of the rule group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public deleteRuleGroup(id: string, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).deleteRuleGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
     * @summary Fire the rule group on your transactions.
     * @param {string} id The ID of the rule group.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. 
     * @param {Array<number>} [accounts] Limit the triggering of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public fireRuleGroup(id: string, start?: string, end?: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).fireRuleGroup(id, start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single rule group. This does not include the rules. For that, see below.
     * @summary Get a single rule group.
     * @param {string} id The ID of the rule group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public getRuleGroup(id: string, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).getRuleGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List rules in this rule group.
     * @summary List rules in this rule group.
     * @param {string} id The ID of the rule group.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public listRuleByGroup(id: string, page?: number, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).listRuleByGroup(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rule groups.
     * @summary List all rule groups.
     * @param {number} [page] Page number. The default pagination is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public listRuleGroup(page?: number, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).listRuleGroup(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new rule group.
     * @param {RuleGroupStore} ruleGroupStore JSON array or key&#x3D;value pairs with the necessary rule group information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public storeRuleGroup(ruleGroupStore: RuleGroupStore, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).storeRuleGroup(ruleGroupStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
     * @summary Test which transactions would be hit by the rule group. No changes will be made.
     * @param {string} id The ID of the rule group.
     * @param {number} [page] Page number. The default pagination is 50 items.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @param {number} [searchLimit] Maximum number of transactions Firefly III will try. Don\&#39;t set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. 
     * @param {number} [triggeredLimit] Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don\&#39;t go above the user\&#39;s page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. 
     * @param {Array<number>} [accounts] Limit the testing of the rule group to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public testRuleGroup(id: string, page?: number, start?: string, end?: string, searchLimit?: number, triggeredLimit?: number, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).testRuleGroup(id, page, start, end, searchLimit, triggeredLimit, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing rule group.
     * @summary Update existing rule group.
     * @param {string} id The ID of the rule group.
     * @param {RuleGroupUpdate} ruleGroupUpdate JSON array with updated rule group information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public updateRuleGroup(id: string, ruleGroupUpdate: RuleGroupUpdate, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).updateRuleGroup(id, ruleGroupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRule: async (id: string, start?: string, end?: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fireRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.X
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRule: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRule: async (ruleStore: RuleStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleStore' is not null or undefined
            assertParamExists('storeRule', 'ruleStore', ruleStore)
            const localVarPath = `/api/v1/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule: async (id: string, start?: string, end?: string, accounts?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testRule', 'id', id)
            const localVarPath = `/api/v1/rules/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (accounts) {
                localVarQueryParameter['accounts[]'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.X
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule: async (id: string, ruleUpdate: RuleUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRule', 'id', id)
            // verify required parameter 'ruleUpdate' is not null or undefined
            assertParamExists('updateRule', 'ruleUpdate', ruleUpdate)
            const localVarPath = `/api/v1/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fireRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fireRule(id, start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.X
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRule(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRule(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeRule(ruleStore: RuleStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeRule(ruleStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testRule(id, start, end, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.X
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRule(id: string, ruleUpdate: RuleUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRule(id, ruleUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Delete an rule.
         * @summary Delete an rule.
         * @param {string} id The ID of the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
         * @summary Fire the rule on your transactions.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.fireRule(id, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single rule.
         * @summary Get a single rule.
         * @param {string} id The ID of the object.X
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(id: string, options?: any): AxiosPromise<RuleSingle> {
            return localVarFp.getRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all rules.
         * @summary List all rules.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRule(page?: number, options?: any): AxiosPromise<RuleArray> {
            return localVarFp.listRule(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new rule
         * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeRule(ruleStore: RuleStore, options?: any): AxiosPromise<RuleSingle> {
            return localVarFp.storeRule(ruleStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
         * @summary Test which transactions would be hit by the rule. No changes will be made.
         * @param {string} id The ID of the rule.
         * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
         * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.testRule(id, start, end, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing rule.
         * @summary Update existing rule.
         * @param {string} id The ID of the object.X
         * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule(id: string, ruleUpdate: RuleUpdate, options?: any): AxiosPromise<RuleSingle> {
            return localVarFp.updateRule(id, ruleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Delete an rule.
     * @summary Delete an rule.
     * @param {string} id The ID of the rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteRule(id: string, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to.
     * @summary Fire the rule on your transactions.
     * @param {string} id The ID of the rule.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the start date is not present, it will be set to one year ago. If you use this field, both the start date and the end date must be present. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. If the end date is not present, it will be set to today. If you use this field, both the start date and the end date must be present. 
     * @param {Array<number>} [accounts] Limit the triggering of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public fireRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).fireRule(id, start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single rule.
     * @summary Get a single rule.
     * @param {string} id The ID of the object.X
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public getRule(id: string, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).getRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all rules.
     * @summary List all rules.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public listRule(page?: number, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).listRule(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new rule
     * @param {RuleStore} ruleStore JSON array or key&#x3D;value pairs with the necessary rule information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public storeRule(ruleStore: RuleStore, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).storeRule(ruleStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to.
     * @summary Test which transactions would be hit by the rule. No changes will be made.
     * @param {string} id The ID of the rule.
     * @param {string} [start] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @param {string} [end] A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. 
     * @param {Array<number>} [accounts] Limit the testing of the rule to these asset accounts or liabilities. Only asset accounts and liabilities will be accepted. Other types will be silently dropped. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public testRule(id: string, start?: string, end?: string, accounts?: Array<number>, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).testRule(id, start, end, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing rule.
     * @summary Update existing rule.
     * @param {string} id The ID of the object.X
     * @param {RuleUpdate} ruleUpdate JSON array with updated rule information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateRule(id: string, ruleUpdate: RuleUpdate, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateRule(id, ruleUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for accounts
         * @summary Search for accounts
         * @param {string} query The query you wish to search for.
         * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: async (query: string, field: AccountSearchFieldFilter, page?: number, type?: AccountTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchAccounts', 'query', query)
            // verify required parameter 'field' is not null or undefined
            assertParamExists('searchAccounts', 'field', field)
            const localVarPath = `/api/v1/search/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches through the users transactions.
         * @summary Search for transactions
         * @param {string} query The query you wish to search for.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransactions: async (query: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchTransactions', 'query', query)
            const localVarPath = `/api/v1/search/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Search for accounts
         * @summary Search for accounts
         * @param {string} query The query you wish to search for.
         * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(query: string, field: AccountSearchFieldFilter, page?: number, type?: AccountTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccounts(query, field, page, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches through the users transactions.
         * @summary Search for transactions
         * @param {string} query The query you wish to search for.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTransactions(query: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTransactions(query, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Search for accounts
         * @summary Search for accounts
         * @param {string} query The query you wish to search for.
         * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(query: string, field: AccountSearchFieldFilter, page?: number, type?: AccountTypeFilter, options?: any): AxiosPromise<AccountArray> {
            return localVarFp.searchAccounts(query, field, page, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches through the users transactions.
         * @summary Search for transactions
         * @param {string} query The query you wish to search for.
         * @param {number} [page] Page number. The default pagination is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransactions(query: string, page?: number, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.searchTransactions(query, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Search for accounts
     * @summary Search for accounts
     * @param {string} query The query you wish to search for.
     * @param {AccountSearchFieldFilter} field The account field(s) you want to search in.
     * @param {number} [page] Page number. The default pagination is 50
     * @param {AccountTypeFilter} [type] The type of accounts you wish to limit the search to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchAccounts(query: string, field: AccountSearchFieldFilter, page?: number, type?: AccountTypeFilter, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchAccounts(query, field, page, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches through the users transactions.
     * @summary Search for transactions
     * @param {string} query The query you wish to search for.
     * @param {number} [page] Page number. The default pagination is 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchTransactions(query: string, page?: number, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchTransactions(query, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SummaryApi - axios parameter creator
 * @export
 */
export const SummaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard. 
         * @summary Returns basic sums of the users data.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicSummary: async (start: string, end: string, currencyCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getBasicSummary', 'start', start)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getBasicSummary', 'end', end)
            const localVarPath = `/api/v1/summary/basic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (currencyCode !== undefined) {
                localVarQueryParameter['currency_code'] = currencyCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SummaryApi - functional programming interface
 * @export
 */
export const SummaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SummaryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard. 
         * @summary Returns basic sums of the users data.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasicSummary(start: string, end: string, currencyCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BasicSummaryEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBasicSummary(start, end, currencyCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SummaryApi - factory interface
 * @export
 */
export const SummaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SummaryApiFp(configuration)
    return {
        /**
         * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard. 
         * @summary Returns basic sums of the users data.
         * @param {string} start A date formatted YYYY-MM-DD. 
         * @param {string} end A date formatted YYYY-MM-DD. 
         * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicSummary(start: string, end: string, currencyCode?: string, options?: any): AxiosPromise<Array<BasicSummaryEntry>> {
            return localVarFp.getBasicSummary(start, end, currencyCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SummaryApi - object-oriented interface
 * @export
 * @class SummaryApi
 * @extends {BaseAPI}
 */
export class SummaryApi extends BaseAPI {
    /**
     * Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is used in Firefly III to populate the dashboard. 
     * @summary Returns basic sums of the users data.
     * @param {string} start A date formatted YYYY-MM-DD. 
     * @param {string} end A date formatted YYYY-MM-DD. 
     * @param {string} [currencyCode] A currency code like EUR or USD, to filter the result. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummaryApi
     */
    public getBasicSummary(start: string, end: string, currencyCode?: string, options?: AxiosRequestConfig) {
        return SummaryApiFp(this.configuration).getBasicSummary(start, end, currencyCode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('deleteTag', 'tag', tag)
            const localVarPath = `/api/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (tag: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getTag', 'tag', tag)
            const localVarPath = `/api/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTag: async (tag: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('listAttachmentByTag', 'tag', tag)
            const localVarPath = `/api/v1/tags/{tag}/attachments`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTag: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByTag: async (tag: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('listTransactionByTag', 'tag', tag)
            const localVarPath = `/api/v1/tags/{tag}/transactions`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTag: async (tagModelStore: TagModelStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagModelStore' is not null or undefined
            assertParamExists('storeTag', 'tagModelStore', tagModelStore)
            const localVarPath = `/api/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagModelStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tag: string, tagModelUpdate: TagModelUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('updateTag', 'tag', tag)
            // verify required parameter 'tagModelUpdate' is not null or undefined
            assertParamExists('updateTag', 'tagModelUpdate', tagModelUpdate)
            const localVarPath = `/api/v1/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagModelUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(tag: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(tag, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByTag(tag: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByTag(tag, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTag(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTag(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionByTag(tag: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionByTag(tag, page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeTag(tagModelStore: TagModelStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeTag(tagModelStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tag: string, tagModelUpdate: TagModelUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tag, tagModelUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Delete an tag.
         * @summary Delete an tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single tag.
         * @summary Get a single tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tag: string, page?: number, options?: any): AxiosPromise<TagSingle> {
            return localVarFp.getTag(tag, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTag(tag: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByTag(tag, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the user\'s tags.
         * @summary List all tags.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTag(page?: number, options?: any): AxiosPromise<TagArray> {
            return localVarFp.listTag(page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions with this tag.
         * @summary List all transactions with this tag.
         * @param {string} tag Either the tag itself or the tag ID.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionByTag(tag: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransactionByTag(tag, page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new tag
         * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTag(tagModelStore: TagModelStore, options?: any): AxiosPromise<TagSingle> {
            return localVarFp.storeTag(tagModelStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing tag.
         * @summary Update existing tag.
         * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
         * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tag: string, tagModelUpdate: TagModelUpdate, options?: any): AxiosPromise<TagSingle> {
            return localVarFp.updateTag(tag, tagModelUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Delete an tag.
     * @summary Delete an tag.
     * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tag: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single tag.
     * @summary Get a single tag.
     * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(tag: string, page?: number, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTag(tag, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} tag Either the tag itself or the tag ID.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listAttachmentByTag(tag: string, page?: number, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).listAttachmentByTag(tag, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the user\'s tags.
     * @summary List all tags.
     * @param {number} [page] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTag(page?: number, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).listTag(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions with this tag.
     * @summary List all transactions with this tag.
     * @param {string} tag Either the tag itself or the tag ID.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
     * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTransactionByTag(tag: string, page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).listTransactionByTag(tag, page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new tag
     * @param {TagModelStore} tagModelStore JSON array or key&#x3D;value pairs with the necessary tag information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public storeTag(tagModelStore: TagModelStore, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).storeTag(tagModelStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing tag.
     * @summary Update existing tag.
     * @param {string} tag Either the tag itself or the tag ID. If you use the tag itself, and it contains international (non-ASCII) characters, your milage may vary.
     * @param {TagModelUpdate} tagModelUpdate JSON array with updated tag information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(tag: string, tagModelUpdate: TagModelUpdate, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTag(tag, tagModelUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransactionJournal', 'id', id)
            const localVarPath = `/api/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionByJournal', 'id', id)
            const localVarPath = `/api/v1/transaction-journals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAttachmentByTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}/attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listEventByTransaction', 'id', id)
            const localVarPath = `/api/v1/transactions/{id}/piggy_bank_events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal: async (id: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listLinksByJournal', 'id', id)
            const localVarPath = `/api/v1/transaction-journals/{id}/links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction: async (page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString().substr(0,10) :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString().substr(0,10) :
                    end;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction: async (transactionStore: TransactionStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionStore' is not null or undefined
            assertParamExists('storeTransaction', 'transactionStore', transactionStore)
            const localVarPath = `/api/v1/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (id: string, transactionUpdate: TransactionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction', 'id', id)
            // verify required parameter 'transactionUpdate' is not null or undefined
            assertParamExists('updateTransaction', 'transactionUpdate', transactionUpdate)
            const localVarPath = `/api/v1/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionJournal(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionJournal(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByJournal(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByJournal(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAttachmentByTransaction(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachmentByTransaction(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventByTransaction(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiggyBankEventArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventByTransaction(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLinksByJournal(id: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionLinkArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLinksByJournal(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransaction(page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransaction(page, start, end, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeTransaction(transactionStore: TransactionStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeTransaction(transactionStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(id: string, transactionUpdate: TransactionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(id, transactionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Delete a transaction.
         * @summary Delete a transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an individual journal (split) from a transaction.
         * @summary Delete split from transaction
         * @param {string} id The ID of the transaction journal (the split) you wish to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionJournal(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransactionJournal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction.
         * @summary Get a single transaction.
         * @param {string} id The ID of the transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(id: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.getTransaction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single transaction by underlying journal (split).
         * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
         * @param {string} id The ID of the transaction journal (split).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByJournal(id: string, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.getTransactionByJournal(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attachments.
         * @summary Lists all attachments.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachmentByTransaction(id: string, page?: number, options?: any): AxiosPromise<AttachmentArray> {
            return localVarFp.listAttachmentByTransaction(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all piggy bank events.
         * @summary Lists all piggy bank events.
         * @param {string} id The ID of the transaction.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventByTransaction(id: string, page?: number, options?: any): AxiosPromise<PiggyBankEventArray> {
            return localVarFp.listEventByTransaction(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
         * @summary Lists all the transaction links for an individual journal (individual split).
         * @param {string} id The ID of the transaction journal / the split.
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLinksByJournal(id: string, page?: number, options?: any): AxiosPromise<TransactionLinkArray> {
            return localVarFp.listLinksByJournal(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user\'s transactions.
         * @summary List all the user\'s transactions. 
         * @param {number} [page] Page number. The default pagination is 50.
         * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
         * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
         * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransaction(page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: any): AxiosPromise<TransactionArray> {
            return localVarFp.listTransaction(page, start, end, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
         * @summary Store a new transaction
         * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeTransaction(transactionStore: TransactionStore, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.storeTransaction(transactionStore, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing transaction.
         * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
         * @param {string} id The ID of the transaction.
         * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(id: string, transactionUpdate: TransactionUpdate, options?: any): AxiosPromise<TransactionSingle> {
            return localVarFp.updateTransaction(id, transactionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Delete a transaction.
     * @summary Delete a transaction.
     * @param {string} id The ID of the transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransaction(id: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an individual journal (split) from a transaction.
     * @summary Delete split from transaction
     * @param {string} id The ID of the transaction journal (the split) you wish to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransactionJournal(id: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteTransactionJournal(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single transaction.
     * @summary Get a single transaction.
     * @param {string} id The ID of the transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransaction(id: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransaction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single transaction by underlying journal (split).
     * @summary Get a single transaction, based on one of the underlying transaction journals (transaction splits).
     * @param {string} id The ID of the transaction journal (split).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionByJournal(id: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionByJournal(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all attachments.
     * @summary Lists all attachments.
     * @param {string} id The ID of the transaction.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listAttachmentByTransaction(id: string, page?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listAttachmentByTransaction(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all piggy bank events.
     * @summary Lists all piggy bank events.
     * @param {string} id The ID of the transaction.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listEventByTransaction(id: string, page?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listEventByTransaction(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the transaction links for an individual journal (a split). Don\'t use the group ID, you need the actual underlying journal (the split).
     * @summary Lists all the transaction links for an individual journal (individual split).
     * @param {string} id The ID of the transaction journal / the split.
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listLinksByJournal(id: string, page?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listLinksByJournal(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user\'s transactions.
     * @summary List all the user\'s transactions. 
     * @param {number} [page] Page number. The default pagination is 50.
     * @param {string} [start] A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). 
     * @param {string} [end] A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). 
     * @param {TransactionTypeFilter} [type] Optional filter on the transaction type(s) returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransaction(page?: number, start?: string, end?: string, type?: TransactionTypeFilter, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransaction(page, start, end, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters.
     * @summary Store a new transaction
     * @param {TransactionStore} transactionStore JSON array or key&#x3D;value pairs with the necessary transaction information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public storeTransaction(transactionStore: TransactionStore, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).storeTransaction(transactionStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing transaction.
     * @summary Update existing transaction. For more information, see https://docs.firefly-iii.org/firefly-iii/api/specials
     * @param {string} id The ID of the transaction.
     * @param {TransactionUpdate} transactionUpdate JSON array with updated transaction information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(id: string, transactionUpdate: TransactionUpdate, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransaction(id, transactionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
         * @summary Delete a user.
         * @param {string} id The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all info of a single user.
         * @summary Get a single user.
         * @param {string} id The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the users in this instance of Firefly III.
         * @summary List all users.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 users per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function. 
         * @summary Store a new user
         * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('storeUser', 'user', user)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing user.
         * @summary Update an existing user\'s information.
         * @param {string} id The user ID.
         * @param {User} user JSON array with updated user information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
         * @summary Delete a user.
         * @param {string} id The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all info of a single user.
         * @summary Get a single user.
         * @param {string} id The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the users in this instance of Firefly III.
         * @summary List all users.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 users per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUser(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUser(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function. 
         * @summary Store a new user
         * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update existing user.
         * @summary Update an existing user\'s information.
         * @param {string} id The user ID.
         * @param {User} user JSON array with updated user information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
         * @summary Delete a user.
         * @param {string} id The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all info of a single user.
         * @summary Get a single user.
         * @param {string} id The user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<UserSingle> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the users in this instance of Firefly III.
         * @summary List all users.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 users per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUser(page?: number, options?: any): AxiosPromise<UserArray> {
            return localVarFp.listUser(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function. 
         * @summary Store a new user
         * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeUser(user: User, options?: any): AxiosPromise<UserSingle> {
            return localVarFp.storeUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing user.
         * @summary Update an existing user\'s information.
         * @param {string} id The user ID.
         * @param {User} user JSON array with updated user information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user: User, options?: any): AxiosPromise<UserSingle> {
            return localVarFp.updateUser(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Delete a user. You cannot delete the user you\'re authenticated with. This cannot be undone. Be careful!
     * @summary Delete a user.
     * @param {string} id The user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all info of a single user.
     * @summary Get a single user.
     * @param {string} id The user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the users in this instance of Firefly III.
     * @summary List all users.
     * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 users per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUser(page?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUser(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the \"forgot password\" function. 
     * @summary Store a new user
     * @param {User} user JSON array or key&#x3D;value pairs with the necessary user information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public storeUser(user: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).storeUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing user.
     * @summary Update an existing user\'s information.
     * @param {string} id The user ID.
     * @param {User} user JSON array with updated user information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, user: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage: async (id: string, messageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhookMessage', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteWebhookMessage', 'messageId', messageId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessageAttempt: async (id: string, messageId: number, attemptId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhookMessageAttempt', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteWebhookMessageAttempt', 'messageId', messageId)
            // verify required parameter 'attemptId' is not null or undefined
            assertParamExists('deleteWebhookMessageAttempt', 'attemptId', attemptId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"attemptId"}}`, encodeURIComponent(String(attemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessage: async (id: string, messageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleWebhookMessage', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getSingleWebhookMessage', 'messageId', messageId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessageAttempt: async (id: string, messageId: number, attemptId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleWebhookMessageAttempt', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getSingleWebhookMessageAttempt', 'messageId', messageId)
            // verify required parameter 'attemptId' is not null or undefined
            assertParamExists('getSingleWebhookMessageAttempt', 'attemptId', attemptId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"attemptId"}}`, encodeURIComponent(String(attemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhook', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessageAttempts: async (id: string, messageId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhookMessageAttempts', 'id', id)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getWebhookMessageAttempts', 'messageId', messageId)
            const localVarPath = `/api/v1/webhooks/{id}/messages/{messageId}/attempts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhookMessages', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhook: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebhook: async (webhookStore: WebhookStore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookStore' is not null or undefined
            assertParamExists('storeWebhook', 'webhookStore', webhookStore)
            const localVarPath = `/api/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookStore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWebook: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitWebook', 'id', id)
            const localVarPath = `/api/v1/webhooks/{id}/submit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (id: string, webhookUpdate: WebhookUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWebhook', 'id', id)
            // verify required parameter 'webhookUpdate' is not null or undefined
            assertParamExists('updateWebhook', 'webhookUpdate', webhookUpdate)
            const localVarPath = `/api/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firefly_iii_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "firefly_iii_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhookMessage(id: string, messageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookMessage(id, messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookMessageAttempt(id, messageId, attemptId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleWebhookMessage(id: string, messageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookMessageSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleWebhookMessage(id, messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookAttemptSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleWebhookMessageAttempt(id, messageId, attemptId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookMessageAttempts(id: string, messageId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookAttemptArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookMessageAttempts(id, messageId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookMessages(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookMessageArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookMessages(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhook(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhook(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeWebhook(webhookStore: WebhookStore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeWebhook(webhookStore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitWebook(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitWebook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(id: string, webhookUpdate: WebhookUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(id, webhookUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Delete a webhook.
         * @summary Delete a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
         * @summary Delete a webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessage(id: string, messageId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhookMessage(id, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
         * @summary Delete a webhook attempt.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook message attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhookMessageAttempt(id, messageId, attemptId, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
         * @summary Get a single message from a webhook.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessage(id: string, messageId: number, options?: any): AxiosPromise<WebhookMessageSingle> {
            return localVarFp.getSingleWebhookMessage(id, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
         * @summary Get a single failed attempt from a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} attemptId The webhook attempt ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: any): AxiosPromise<WebhookAttemptSingle> {
            return localVarFp.getSingleWebhookMessageAttempt(id, messageId, attemptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all info of a single webhook.
         * @summary Get a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id: string, options?: any): AxiosPromise<WebhookSingle> {
            return localVarFp.getWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
         * @summary Get all the failed attempts of a single webhook message.
         * @param {string} id The webhook ID.
         * @param {number} messageId The webhook message ID.
         * @param {number} [page] Page number. The default pagination is per 50 items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessageAttempts(id: string, messageId: number, page?: number, options?: any): AxiosPromise<WebhookAttemptArray> {
            return localVarFp.getWebhookMessageAttempts(id, messageId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
         * @summary Get all the messages of a single webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookMessages(id: string, options?: any): AxiosPromise<WebhookMessageArray> {
            return localVarFp.getWebhookMessages(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user\'s webhooks.
         * @summary List all webhooks.
         * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhook(page?: number, options?: any): AxiosPromise<WebhookArray> {
            return localVarFp.listWebhook(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
         * @summary Store a new webhook
         * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeWebhook(webhookStore: WebhookStore, options?: any): AxiosPromise<WebhookSingle> {
            return localVarFp.storeWebhook(webhookStore, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
         * @summary Submit messages for a webhook.
         * @param {string} id The webhook ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWebook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.submitWebook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
         * @summary Update existing webhook.
         * @param {string} id The webhook ID.
         * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(id: string, webhookUpdate: WebhookUpdate, options?: any): AxiosPromise<WebhookSingle> {
            return localVarFp.updateWebhook(id, webhookUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Delete a webhook.
     * @summary Delete a webhook.
     * @param {string} id The webhook ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook message. Any time a webhook is triggered the message is stored before it\'s sent. You can delete them before or after sending.
     * @summary Delete a webhook message.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhookMessage(id: string, messageId: number, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhookMessage(id, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
     * @summary Delete a webhook attempt.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {number} attemptId The webhook message attempt ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhookMessageAttempt(id, messageId, attemptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
     * @summary Get a single message from a webhook.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getSingleWebhookMessage(id: string, messageId: number, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getSingleWebhookMessage(id, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
     * @summary Get a single failed attempt from a single webhook message.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {number} attemptId The webhook attempt ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getSingleWebhookMessageAttempt(id: string, messageId: number, attemptId: number, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getSingleWebhookMessageAttempt(id, messageId, attemptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all info of a single webhook.
     * @summary Get a single webhook.
     * @param {string} id The webhook ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook message fails to send it will store the failure in an \"attempt\". You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
     * @summary Get all the failed attempts of a single webhook message.
     * @param {string} id The webhook ID.
     * @param {number} messageId The webhook message ID.
     * @param {number} [page] Page number. The default pagination is per 50 items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhookMessageAttempts(id: string, messageId: number, page?: number, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhookMessageAttempts(id, messageId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When a webhook is triggered the actual message that will be send is stored in a \"message\". You can view and analyse these messages.
     * @summary Get all the messages of a single webhook.
     * @param {string} id The webhook ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhookMessages(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhookMessages(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user\'s webhooks.
     * @summary List all webhooks.
     * @param {number} [page] The page number, if necessary. The default pagination is 50, so 50 webhooks per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhook(page?: number, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).listWebhook(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret. 
     * @summary Store a new webhook
     * @param {WebhookStore} webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public storeWebhook(webhookStore: WebhookStore, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).storeWebhook(webhookStore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can\'t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * @summary Submit messages for a webhook.
     * @param {string} id The webhook ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public submitWebook(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).submitWebook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing webhook\'s information. If you wish to reset the secret, submit any value as the \"secret\". Firefly III will take this as a hint and reset the secret of the webhook.
     * @summary Update existing webhook.
     * @param {string} id The webhook ID.
     * @param {WebhookUpdate} webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(id: string, webhookUpdate: WebhookUpdate, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhook(id, webhookUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


